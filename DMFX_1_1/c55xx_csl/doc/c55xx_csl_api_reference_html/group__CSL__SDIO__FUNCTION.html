<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>C55XX CSL LP: SDIO Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">C55XX CSL LP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SDIO Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__CSL__SDIO__API.html">SDIO</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga31c42ff95095f6e7bb1cd0ccaf9232dd">SDIO_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioControllerObj</a> *pSdioContObj, <a class="el" href="group__CSL__SDIO__ENUM.html#gaf40d2888ecc00c3f539b9a8fc839e44d">CSL_SdioInstId</a> instId, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga01742cf6293945fe175e63d11621b7cc">SDIO_close</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga5d375bbc6ee8daf543cb1e9ed043710d">SDIO_config</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, <a class="el" href="structCSL__SdioConfig.html">CSL_SdioConfig</a> *pSdioConfig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gaab17a7632f94926ceae28afa8b92f5b4">SDIO_detectCard</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, <a class="el" href="structCSL__SdioCardObj.html">CSL_SdioCardObj</a> *pSdioCardObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 OpCondReg, Bool initMem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga04b9473a115e459e9cef487fd1e9b106">SDIO_resetCard</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga15a377b20329eb977b6402e05eac90ec">SDIO_getRca</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint16 *pRCardAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gafc601bd391e0e4a8dfac35d04249672d">SDIO_deselectCard</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gaac2b525ee39fd26e8894a9c53baa9e46">SDIO_selectCard</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint16 rca)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga7f84631328c46f6a4fafe5887f8584ec">SDIO_sendCommand</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 cmd, Uint32 arg, Uint16 respTimeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga9af0b043db7c2b4127b01a281f432d3e">SDIO_getResponse</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, <a class="el" href="group__CSL__SDIO__ENUM.html#ga26f8789e409d20cd6ecd441f895df448">CSL_SdioRespType</a> respType, <a class="el" href="structCSL__SdioResponse.html">CSL_SdioResponse</a> *pResponse)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gadbd0533a5abbfbcc761b9124a83bf6ab">SDIO_clearResponse</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa8d7531101fd009b0338a131e137acea">SDIO_getStatus</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 maskValue, CSL_Status *pStatus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga71a42c6355ecc3bc548fe12d1e782556">SDIO_getSdioStatus</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 maskValue, CSL_Status *pStatus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga5137bffccb53e0eefcbbd84d9335b6a2">SDIO_eventEnable</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, <a class="el" href="group__CSL__SDIO__ENUM.html#ga02e4f43d3d750a216f087cf9852e4d0b">CSL_SdioEventType</a> sdioEvent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa3cb46a0e972a8fc8ba5a84ae166af03">SDIO_eventDisable</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, <a class="el" href="group__CSL__SDIO__ENUM.html#ga02e4f43d3d750a216f087cf9852e4d0b">CSL_SdioEventType</a> sdioEvent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga3d441ac85bdd95f8ddf462a707313b07">SDIO_readWaitEnable</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga53ba036f2a9948bb14e750b62eef7bf8">SDIO_readWaitDisable</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gadd07b1a85238e2c5b7172e82af4bfc5d">SDIO_readSingleByte</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 readAddr, Uint8 funNum, Uint8 *pReadData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga72f69500a0a64db9cb3029da7b676184">SDIO_writeSingleByte</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 writeAddr, Uint8 funNum, Uint8 writeData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga78cfcd442a8a886218a0e8036a435f1b">SDIO_readBytes</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 readAddr, Uint8 funNum, Bool opCode, Uint16 noOfBytes, Uint16 *pReadBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga5d463e7e61b5ba8937592bf5208b84b1">SDIO_writeBytes</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 writeAddr, Uint8 funNum, Bool opCode, Uint16 noOfBytes, Uint16 *pWriteBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga9ea488648e5653e9b1132e1d9e76283e">SDIO_readBlocks</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 readAddr, Uint8 funNum, Bool opCode, Uint16 noOfBlocks, Uint16 blockSize, Uint16 *pReadBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga72157ae53ee109f587b92e21afb3baae">SDIO_writeBlocks</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint32 writeAddr, Uint8 funNum, Bool opCode, Uint16 noOfBlocks, Uint16 blockSize, Uint16 *pWriteBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#gaac86fe23943b0704aabbabd0b52c487d">SDIO_setEndianMode</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, <a class="el" href="group__CSL__SDIO__ENUM.html#gaf55cbe11285d205d4194b517e83dca24">CSL_SdioEndianMode</a> writeEndianMode, <a class="el" href="group__CSL__SDIO__ENUM.html#gaf55cbe11285d205d4194b517e83dca24">CSL_SdioEndianMode</a> readEndianMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__SDIO__FUNCTION.html#ga3fe0a1dc63e8e456235bf61cf917adeb">SDIO_setClock</a> (<a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> hSdio, Uint16 clockRate)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadbd0533a5abbfbcc761b9124a83bf6ab"></a><!-- doxytag: member="csl_sdio.h::SDIO_clearResponse" ref="gadbd0533a5abbfbcc761b9124a83bf6ab" args="(CSL_SdioHandle hSdio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_clearResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_clearResponse</b> </p>
<p><b>Description</b> <br/>
 This function is used to clear all the response registers.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 Response structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            CSL_SdioResponse         response;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_clearResponse(hSdio);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga01742cf6293945fe175e63d11621b7cc"></a><!-- doxytag: member="csl_sdio.h::SDIO_close" ref="ga01742cf6293945fe175e63d11621b7cc" args="(CSL_SdioHandle hSdio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_close</b> </p>
<p><b>Description</b> <br/>
 This function closes the specified handle to SDIO.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio            Handle to the SDIO
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully before this function.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 SDIO handle</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_close(hSdio);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga5d375bbc6ee8daf543cb1e9ed043710d"></a><!-- doxytag: member="csl_sdio.h::SDIO_config" ref="ga5d375bbc6ee8daf543cb1e9ed043710d" args="(CSL_SdioHandle hSdio, CSL_SdioConfig *pSdioConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__SdioConfig.html">CSL_SdioConfig</a> *&#160;</td>
          <td class="paramname"><em>pSdioConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_config</b> </p>
<p><b>Description</b> <br/>
 This function configures the SDIO controller hardware registers.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio              Handle to the SDIO.
            pSdioConfig        Pointer to the SDIO config Parameter.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called before this function.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 SDIO Registers.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            CSL_SdioConfig           sdioConfig;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            // Initialize SDIO configuration structure
            sdioConfig.mmcctl  = .... ;
            ...
            ...
            sdioConfig.sdioien = .... ;


            // Configure SDIO
            status = SDIO_config(hSdio, &amp;sdioConfig);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gafc601bd391e0e4a8dfac35d04249672d"></a><!-- doxytag: member="csl_sdio.h::SDIO_deselectCard" ref="gafc601bd391e0e4a8dfac35d04249672d" args="(CSL_SdioHandle hSdio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_deselectCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_deselectCard</b> </p>
<p><b>Description</b> <br/>
 This function is used to deselect SDIO which has been selected earlier. CMD7 shall be sent to the SDIO card with the relative card address set to 0x0000.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio      Handle to the SDIO.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called. <br/>
 3:Card should be active</p>
<p><b> Post Condition </b> <br/>
 Deselects the SDIO card</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            CSL_SdioCardObj          sdioCardObj;
            Uint32                   ocr;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            status = SDIO_initCard(hSdio, ocr, TRUE);

            status = SDIO_deselectCard(hSdio);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaab17a7632f94926ceae28afa8b92f5b4"></a><!-- doxytag: member="csl_sdio.h::SDIO_detectCard" ref="gaab17a7632f94926ceae28afa8b92f5b4" args="(CSL_SdioHandle hSdio, CSL_SdioCardObj *pSdioCardObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_detectCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__SdioCardObj.html">CSL_SdioCardObj</a> *&#160;</td>
          <td class="paramname"><em>pSdioCardObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_detectCard</b> </p>
<p><b>Description</b> <br/>
 This function is used to detect type of the SDIO card inserted. This function sends SDIO specification defined command sequence to detect type of the card. Type of the card shall be populated in pSdioCardObj. This function also populates other fields of card object structure. Address pointed by 'pSdioCardObj' should be global structure variable which persists till end of the program since it is stored by SDIO CSL for reference in other APIs. This API returns success only incase of SDIO card inserted into the MMC/SD slot of the EVM. For the SDIO cards which returns OCR value as 0, card type will be set to 'CSL_SDIO_INVALID_CARD'. Application/Driver programs should validate card type and ocr value updated in the card object structure to proceed further.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio              Handle to the SDIO.
            pSdioCardObj       Pointer to SDIO card object structure
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESYS_FAIL - Card detection failed </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called before this function.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 pSdioCardObj</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            CSL_SdioCardObj          sdioCardObj;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaa3cb46a0e972a8fc8ba5a84ae166af03"></a><!-- doxytag: member="csl_sdio.h::SDIO_eventDisable" ref="gaa3cb46a0e972a8fc8ba5a84ae166af03" args="(CSL_SdioHandle hSdio, CSL_SdioEventType sdioEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_eventDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__SDIO__ENUM.html#ga02e4f43d3d750a216f087cf9852e4d0b">CSL_SdioEventType</a>&#160;</td>
          <td class="paramname"><em>sdioEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_eventDisable</b> </p>
<p><b>Description</b> <br/>
 This function will disable the events in the MMC interrupt mask register and SDIO interrupt enable register.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio         Handle to the SDIO.
            sdioEvent     Event type.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Disables the given event</p>
<p><b>Modifies</b> <br/>
 MMC/SDIO Interrupt Mask Register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_eventDisable(hSdio, CSL_SDIO_EDRRDY_INTERRUPT);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga5137bffccb53e0eefcbbd84d9335b6a2"></a><!-- doxytag: member="csl_sdio.h::SDIO_eventEnable" ref="ga5137bffccb53e0eefcbbd84d9335b6a2" args="(CSL_SdioHandle hSdio, CSL_SdioEventType sdioEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_eventEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__SDIO__ENUM.html#ga02e4f43d3d750a216f087cf9852e4d0b">CSL_SdioEventType</a>&#160;</td>
          <td class="paramname"><em>sdioEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_eventEnable</b> </p>
<p><b>Description</b> <br/>
 This function will enable the events in the MMC interrupt mask register and SDIO interrupt enable register.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio         Handle to the SDIO.
            sdioEvent     Event type.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Enables the given event</p>
<p><b>Modifies</b> <br/>
 MMC/SDIO Interrupt Mask Registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_eventEnable(hSdio, CSL_SDIO_EDRRDY_INTERRUPT);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga15a377b20329eb977b6402e05eac90ec"></a><!-- doxytag: member="csl_sdio.h::SDIO_getRca" ref="ga15a377b20329eb977b6402e05eac90ec" args="(CSL_SdioHandle hSdio, Uint16 *pRCardAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_getRca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pRCardAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_getRca</b> </p>
<p><b>Description</b> <br/>
 This function is used to read new relative card address from the card. This function sends CMD3 and reads relative card address. RCA read from the card will be populated to the pRCardAddr and card object structure in SDIO handle.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio            Handle to the SDIO.
            pRCardAddr       Relative card address.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 pRCardAddr variable will be populated.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint16                   rca;
            Uint32                   ocr;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_initCard(hSdio, ocr, TRUE);

            status = SDIO_getRca(hSdio, &amp;rca);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga9af0b043db7c2b4127b01a281f432d3e"></a><!-- doxytag: member="csl_sdio.h::SDIO_getResponse" ref="ga9af0b043db7c2b4127b01a281f432d3e" args="(CSL_SdioHandle hSdio, CSL_SdioRespType respType, CSL_SdioResponse *pResponse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_getResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__SDIO__ENUM.html#ga26f8789e409d20cd6ecd441f895df448">CSL_SdioRespType</a>&#160;</td>
          <td class="paramname"><em>respType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__SdioResponse.html">CSL_SdioResponse</a> *&#160;</td>
          <td class="paramname"><em>pResponse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_getResponse</b> </p>
<p><b>Description</b> <br/>
 This function is used to read the response registers. This function reads response registers based on the response type and populates the response structure. Response registers are not cleared by this function.</p>
<p><br/>
 Response type Response bits Resp buf Fields populated <br/>
 ============== ============ ========================= <br/>
 R1,R3,R4,R5,R6 [23:8] pResponse-&gt;respBuf[6] <br/>
 [39:24] pResponse-&gt;respBuf[7] <br/>
 <br/>
 R2 [15:0] pResponse-&gt;respBuf[0] <br/>
 [31:16] pResponse-&gt;respBuf[1] <br/>
 [47:32] pResponse-&gt;respBuf[2] <br/>
 [63:48] pResponse-&gt;respBuf[3] <br/>
 [79:64] pResponse-&gt;respBuf[4] <br/>
 [95:80] pResponse-&gt;respBuf[5] <br/>
 [111:96] pResponse-&gt;respBuf[6] <br/>
 [127:112] pResponse-&gt;respBuf[7]</p>
<p>NOTE: IF RESPONSE TYPE SENT IS NOT RECOGNIZED BY THIS API ALL THE RESPONSE REGISTERS ARE POPULATED IN THE SAME FORMAT MENTIONED ABOVE FOR R2 RESPONSE.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            respType       Type of the response
            pResponse      Pointer to response structure
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#ga7f84631328c46f6a4fafe5887f8584ec">SDIO_sendCommand()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 Response structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint32                   cmd;
            Uint32                   arg;
            Uint16                   respTimeout;
            CSL_SdioResponse         response;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            //Send Command 5
            cmd         = 0x205;
            arg         = 0;
            respTimeout = 0xFFFF;
            status = SDIO_sendCommand(hSdio, cmd, arg, respTimeout);

            status = SDIO_getResponse(hSdio, CSL_SDIO_RESPTYPE_R4, &amp;response);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga71a42c6355ecc3bc548fe12d1e782556"></a><!-- doxytag: member="csl_sdio.h::SDIO_getSdioStatus" ref="ga71a42c6355ecc3bc548fe12d1e782556" args="(CSL_SdioHandle hSdio, Uint32 maskValue, CSL_Status *pStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDIO_getSdioStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>maskValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_getSdioStatus</b> </p>
<p><b>Description</b> <br/>
 This function reads SDIOST0 and SDIOIST registers and returns the value. When mask value is set to 0xFFFFFFFF, value of SDIOST0 will be stored in lower 16 bits and value of SDIOIST will be store in upper 16 bits. Value of a particular bit in the passed mask should be set to '1' to read the corresponding bit in the SDIO status register.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            maskValue      Mask value to specify the field.
            pStatus        status of API Success of Failed.
     </pre></div><p><b> Return Value </b> Uint32 Status - SDIOST0 and SDIOIST register value.</p>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint32                   sdiostatus;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            sdiostatus = SDIO_getSdioStatus(hSdio, 0xFFFF, &amp;status);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaa8d7531101fd009b0338a131e137acea"></a><!-- doxytag: member="csl_sdio.h::SDIO_getStatus" ref="gaa8d7531101fd009b0338a131e137acea" args="(CSL_SdioHandle hSdio, Uint32 maskValue, CSL_Status *pStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 SDIO_getStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>maskValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_getStatus</b> </p>
<p><b>Description</b> <br/>
 This function reads MMCST0 and MMCST1 registers and returns the value. When mask value is set to 0xFFFFFFFF, value of MMCST0 will be stored in lower 16 bits and value of MMCST1 will be store in upper 16 bits. Value of a particular bit in the passed mask should be set to '1' to read the corresponding bit in the MMC status register.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            maskValue      Mask value to specify the field.
            pStatus        Status of API Success or Failed.
     </pre></div><p><b> Return Value </b> Uint32 Status - MMCST0 and MMCST1 register value.</p>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint32                   mmcstatus;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            mmcstatus = SDIO_getStatus(hSdio, 0xFFFF, &amp;status);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga31c42ff95095f6e7bb1cd0ccaf9232dd"></a><!-- doxytag: member="csl_sdio.h::SDIO_init" ref="ga31c42ff95095f6e7bb1cd0ccaf9232dd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_init</b> </p>
<p><b>Description</b> <br/>
 This is the initialization function for the SDIO CSL. The function must be called before calling any other API from this CSL. This function is for enabling the clock to the SDIO Controller. This function should be called only once during system initialization time. This function gates the clock for the two MMCSD modules. Application programs may disable the clocks for MMCSD module which is not in use.</p>
<p>NOTE: Calling this function is not required if MMC_init is called since both functions use the same MMCSD controller</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Always returns</li>
</ul>
<p><b> Pre Condition </b> <br/>
 This should be called before calling any other SDIO Function.</p>
<p><b> Post Condition </b> <br/>
 Enables clock for MMCSD controller</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_status       status;

            status = SDIO_init();
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gae5f1f0eb79e89a68e959beed2579fa0a"></a><!-- doxytag: member="csl_sdio.h::SDIO_initCard" ref="gae5f1f0eb79e89a68e959beed2579fa0a" args="(CSL_SdioHandle hSdio, Uint32 OpCondReg, Bool initMem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_initCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>OpCondReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>initMem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_initCard</b> </p>
<p><b>Description</b> <br/>
 This function is used to initialize the SDIO card inserted. This function sends SDIO specification defined command sequence to initialize the SDIO card. Proper OCR value should be sent to this function based on the OCR value received from the card during card detection. SDIO card shall be ready to use after successful execution of this function. This function also supports initializing memory portion of the COMBO SDIO card. Parameter 'initMem' is useful to select(initMem = 1) or skip(initMem = 0) the initialization of COMBO SDIO cards. This function returns with error incase of IO portion or memory(COMBO) portion of the card is not ready.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio        Handle to the SDIO.
            OpCondReg    Operation Conditions Regsiter(OCR) value
            initMem      Flag to select/skip memory initialization
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error </li>
<li>CSL_ESDIO_IO_NOTREADY - Card IO is not ready </li>
<li>CSL_ESDIO_MEM_NOTREADY - Card memory is not ready</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaab17a7632f94926ceae28afa8b92f5b4">SDIO_detectCard()</a> API should be called before this function.</p>
<p><b> Post Condition </b> <br/>
 Initializes SDIO card</p>
<p><b>Modifies</b> <br/>
 SDIO card registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            CSL_SdioCardObj          sdioCardObj;
            Uint32                   ocr;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            status = SDIO_initCard(hSdio, ocr, TRUE);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaa45b55576f0863337fb9e984fab1d03f"></a><!-- doxytag: member="csl_sdio.h::SDIO_open" ref="gaa45b55576f0863337fb9e984fab1d03f" args="(CSL_SdioControllerObj *pSdioContObj, CSL_SdioInstId instId, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a> SDIO_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioControllerObj</a> *&#160;</td>
          <td class="paramname"><em>pSdioContObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__SDIO__ENUM.html#gaf40d2888ecc00c3f539b9a8fc839e44d">CSL_SdioInstId</a>&#160;</td>
          <td class="paramname"><em>instId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_open</b> </p>
<p><b>Description</b> <br/>
 This function opens the CSL SDIO module and returns handle to the SDIO object structure.</p>
<p>NOTE: THIS API SETS THE ENDIAN MODE OF SDIO READ AND WRITE OPERATIONS TO LITTLE ENDIAN. USE <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaac86fe23943b0704aabbabd0b52c487d">SDIO_setEndianMode()</a> TO CHANGE ENDIAN MODE.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pSdioContObj    SDIO Controller object structure
            instId          Instance number for SDIO
            status          Status of the function
     </pre></div><p><b> Return Value </b> CSL_SdioHandle <br/>
 Valid SDIO handle will be returned if status value is equal to CSL_SOK.</p>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#ga31c42ff95095f6e7bb1cd0ccaf9232dd">SDIO_init()</a> API should be called before <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a>.</p>
<p><b> Post Condition </b> <br/>
 1. The status is returned in the status variable. If status returned is </p>
<ul>
<li>CSL_SOK - Valid SDIO handle is returned </li>
<li>CSL_ESYS_INVPARAMS - Resource is already in use <br/>
 2. CSL_SdioObj object structure is populated</li>
</ul>
<p><b>Modifies</b> <br/>
 1. Status variable <br/>
 2. CSL_SdioObj object structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio = SDIO_open(&amp;sdioContObj, instId, &amp;status);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga9ea488648e5653e9b1132e1d9e76283e"></a><!-- doxytag: member="csl_sdio.h::SDIO_readBlocks" ref="ga9ea488648e5653e9b1132e1d9e76283e" args="(CSL_SdioHandle hSdio, Uint32 readAddr, Uint8 funNum, Bool opCode, Uint16 noOfBlocks, Uint16 blockSize, Uint16 *pReadBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_readBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>readAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>funNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>opCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>noOfBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pReadBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_readBlocks</b> </p>
<p><b>Description</b> <br/>
 This function reads requested number of blocks of data from SDIO card. 'readAddr' is address on the SDIO card from where the reading starts. Block size of IO function to read data should be configured before calling this function.</p>
<p>Reading of data can be done from a fixed address(opCode = 0) or incrementing address(opCode = 1). Fixed mode data read is useful when I/O data is transferred using a FIFO inside SDIO card. Opcode should be 1 for the SDIO cards which doesn't have support for FIFO.</p>
<p>NOTE: Endian mode of the data transfer depends on the parameter 'readEndianMode' in the SDIO handle. Default value for the endian mode is 'LITTLE ENDIAN' which will be set during SDIO open. Endian mode can be configured using <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaac86fe23943b0704aabbabd0b52c487d">SDIO_setEndianMode()</a>. DO NOT CHANGE THE ENDIAN MODE WITH OUT USING THIS API.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            readAddr       Location to read from.
            funNum         IO function number to read data
            opCode         Bit to decide source address mode
                           - Fixed/Incrementing
            noOfBlocks     Number of blocks to read.
            blockSize      Size of each block
            pReadBuf       pointer to a buffer.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Reads data from the SDIO card</p>
<p><b>Modifies</b> <br/>
 readBuffer will be populated.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint32                   ocr;
            Uint16                   readBuf[512];
            Uint32                   readAddr;
            Uint16                   noOfBlocks;
            Bool                     opCode;
            Uint8                    funNum;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            status = SDIO_initCard(hSdio, ocr, TRUE);

            readAddr   = 0x0;
            noOfBlocks = 2;
            opCode     = 1;
            funNum     = 0;

            status = SDIO_readBlocks(hSdio, readAddr, funNum, opCode,
                                     noOfBlocks, 256, readBuf);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga78cfcd442a8a886218a0e8036a435f1b"></a><!-- doxytag: member="csl_sdio.h::SDIO_readBytes" ref="ga78cfcd442a8a886218a0e8036a435f1b" args="(CSL_SdioHandle hSdio, Uint32 readAddr, Uint8 funNum, Bool opCode, Uint16 noOfBytes, Uint16 *pReadBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_readBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>readAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>funNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>opCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>noOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pReadBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_readBytes</b> </p>
<p><b>Description</b> <br/>
 This function reads requested number of bytes from the SDIO card. 'readAddr' is address on the SDIO card from where the reading starts. This function reads multiple bytes of data from the given address and populates into read buffer. Maximum number of bytes that can be read using this function are 512.</p>
<p>Reading of data can be done from a fixed address(opCode = 0) or incrementing address(opCode = 1). Fixed mode data read is useful when I/O data is transferred using a FIFO inside SDIO card. Opcode should be 1 for the SDIO cards which doesn't have support for FIFO.</p>
<p>NOTE: Endian mode of the data transfer depends on the parameter 'readEndianMode' in the SDIO handle. Default value for the endian mode is 'LITTLE ENDIAN' which will be set during SDIO open. Endian mode can be configured using <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaac86fe23943b0704aabbabd0b52c487d">SDIO_setEndianMode()</a>. DO NOT CHANGE THE ENDIAN MODE WITH OUT USING THIS API.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            readAddr       Location to read from.
            funNum         IO function number to read data
            opCode         Bit to decide source address mode
                             - Fixed/Incrementing
            noOfBytes      no of bytes to read.
            pReadBuf       pointer to a buffer.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Reads data from the SDIO card</p>
<p><b>Modifies</b> <br/>
 readBuffer will be populated.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint16                   rca;
            Uint32                   ocr;
            Uint16                   readBuf[512];
            Uint32                   readAddr;
            Uint16                   noOfBytes;
            Bool                     opCode;
            Uint8                    funNum;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            status = SDIO_initCard(hSdio, ocr, TRUE);

            readAddr  = 0x0;
            noOfBytes = 16;
            opCode    = 1;
            funNum    = 0;

            status = SDIO_readBytes(hSdio, readAddr, funNum, opCode,
                                    noOfBytes, readBuf);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gadd07b1a85238e2c5b7172e82af4bfc5d"></a><!-- doxytag: member="csl_sdio.h::SDIO_readSingleByte" ref="gadd07b1a85238e2c5b7172e82af4bfc5d" args="(CSL_SdioHandle hSdio, Uint32 readAddr, Uint8 funNum, Uint8 *pReadData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_readSingleByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>readAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>funNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pReadData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_readSingleByte</b> </p>
<p><b>Description</b> <br/>
 This function reads a single byte of data from the SDIO card. 'readAddr' is address on the SDIO card from where data byte will be read. Command 52 (IO_RW_DIRECT Command) is used to read the data.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            readAddr       Location to read from.
            funNum         IO function number to read data
            pReadData      Pointer to populate data read
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Reads a byte of data from the SDIO card</p>
<p><b>Modifies</b> <br/>
 Read data pointer will be populated.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint16                   rca;
            Uint32                   ocr;
            Uint8                    readData;
            Uint32                   readAddr;
            Uint8                    funNum;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            status = SDIO_initCard(hSdio, ocr, TRUE);

            readAddr  = 0x0;
            funNum    = 0;

            status = SDIO_readSingleByte(hSdio, readAddr, funNum, &amp;readData);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga53ba036f2a9948bb14e750b62eef7bf8"></a><!-- doxytag: member="csl_sdio.h::SDIO_readWaitDisable" ref="ga53ba036f2a9948bb14e750b62eef7bf8" args="(CSL_SdioHandle hSdio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_readWaitDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_readWaitDisable</b> </p>
<p><b>Description</b> <br/>
 This function is used to disable SDIO read-wait bit in SDIO control register.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio             Handle to the SDIO.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Disables the sdio read-wait</p>
<p><b>Modifies</b> <br/>
 SDIO control Register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_readWaitDisable(hSdio);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga3d441ac85bdd95f8ddf462a707313b07"></a><!-- doxytag: member="csl_sdio.h::SDIO_readWaitEnable" ref="ga3d441ac85bdd95f8ddf462a707313b07" args="(CSL_SdioHandle hSdio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_readWaitEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_readWaitEnable</b> </p>
<p><b>Description</b> <br/>
 This function is used to enable SDIO read-wait bit in SDIO control register.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio             Handle to the SDIO.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Enables the sdio read-wait</p>
<p><b>Modifies</b> <br/>
 SDIO control Register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_readWaitEnable(hSdio);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga04b9473a115e459e9cef487fd1e9b106"></a><!-- doxytag: member="csl_sdio.h::SDIO_resetCard" ref="ga04b9473a115e459e9cef487fd1e9b106" args="(CSL_SdioHandle hSdio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_resetCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_resetCard</b> </p>
<p><b>Description</b> <br/>
 This function is used to reset the SDIO card. This function uses CMD52 to reset SDIO card. After execution of this function SDIO card will not receive any commands except CMD5.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio              Handle to the SDIO.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called before this function.</p>
<p><b> Post Condition </b> <br/>
 Resets SDIO card</p>
<p><b>Modifies</b> <br/>
 SDIO card registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_resetCard(hSdio);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaac2b525ee39fd26e8894a9c53baa9e46"></a><!-- doxytag: member="csl_sdio.h::SDIO_selectCard" ref="gaac2b525ee39fd26e8894a9c53baa9e46" args="(CSL_SdioHandle hSdio, Uint16 rca)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_selectCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>rca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_selectCard</b> </p>
<p><b>Description</b> <br/>
 This function is used to select SDIO card. CMD7 shall be sent to the SDIO card along with the relative card address to select the card. RCA value should be the one published by the card. Sending CMD7 with invalid RCA will put the card into standby/disabled state.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio      Handle to the SDIO.
            rca        Relative card address.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called.</p>
<p><b> Post Condition </b> <br/>
 Selects the SDIO card</p>
<p><b>Modifies</b> <br/>
 rca</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint16                   rca;
            Uint32                   ocr;
            CSL_SdioCardObj          sdioCardObj;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            rca = sdioCardObj.rca;

            status = SDIO_initCard(hSdio, ocr, TRUE);

            status = SDIO_selectCard(hSdio, rca);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga7f84631328c46f6a4fafe5887f8584ec"></a><!-- doxytag: member="csl_sdio.h::SDIO_sendCommand" ref="ga7f84631328c46f6a4fafe5887f8584ec" args="(CSL_SdioHandle hSdio, Uint32 cmd, Uint32 arg, Uint16 respTimeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_sendCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>respTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_sendCommand</b> </p>
<p><b>Description</b> <br/>
 This function is used to send commands to the SDIO card. This function sends given command to the card and waits for the response. Lower 16 bits of the parameter 'cmd' should contain the command that needs to be written to MMCCMD1 register. Upper 16 bits of the 'cmd' should contain the data that needs to be written to MMCCMD2 register.</p>
<p>NOTE:SETTING THE MMCCMD2 VALUE TO '1' IS ALLOWED ONLY FOR DATA WRITE COMMANDS THAT USES DMA FOR DATA TRANSFER. FOR OTHER COMMANDS UPPER 16 BITS OF 'CMD' SHOULD ALWAYS BE ZERO.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            cmd            MMCCMD1 and MMCCMD2 register value.
            arg            Command argument.
            respTimeout    Timeout value for the response.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Sends command to the card</p>
<p><b>Modifies</b> <br/>
 Card Command registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint32                   cmd;
            Uint32                   arg;
            Uint16                   respTimeout;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            //Send Command 5
            cmd         = 0x205;
            arg         = 0;
            respTimeout = 0xFFFF;
            status = SDIO_sendCommand(hSdio, cmd, arg, respTimeout);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga3fe0a1dc63e8e456235bf61cf917adeb"></a><!-- doxytag: member="csl_sdio.h::SDIO_setClock" ref="ga3fe0a1dc63e8e456235bf61cf917adeb" args="(CSL_SdioHandle hSdio, Uint16 clockRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_setClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>clockRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_setClock</b> </p>
<p><b>Description</b> <br/>
 This function is used to set SDIO controller clock divider value. Clock controller register bits are configured by this function. Clock rate or clock divider value can range from 0 to 0xFF.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio        Handle to the SDIO.
            clockRate    Value of clock rate
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Sets SDIO clock</p>
<p><b>Modifies</b> <br/>
 SDIO clock control register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_setClock(hSdio, 5);
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaac86fe23943b0704aabbabd0b52c487d"></a><!-- doxytag: member="csl_sdio.h::SDIO_setEndianMode" ref="gaac86fe23943b0704aabbabd0b52c487d" args="(CSL_SdioHandle hSdio, CSL_SdioEndianMode writeEndianMode, CSL_SdioEndianMode readEndianMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_setEndianMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__SDIO__ENUM.html#gaf55cbe11285d205d4194b517e83dca24">CSL_SdioEndianMode</a>&#160;</td>
          <td class="paramname"><em>writeEndianMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__SDIO__ENUM.html#gaf55cbe11285d205d4194b517e83dca24">CSL_SdioEndianMode</a>&#160;</td>
          <td class="paramname"><em>readEndianMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_setEndianMode</b> </p>
<p><b>Description</b> <br/>
 This function is used to set endian mode of the SDIO controller. Endian mode set using this API decides the way in which data is transferred from FIFO to storage device.</p>
<p>Default endianness of SDIO controller: Chip C5504 and C5505: LITTLE ENDIAN. Chip C5514 and C5515: BIG ENDIAN.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio              Handle to the SDIO.
            writeEndianMode    Endian mode for SDIO write operation
            readEndianMode     Endian mode for SDIO read operation
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Sets SDIO endian mode for write and read operations</p>
<p><b>Modifies</b> <br/>
 SDIO control register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_setEndianMode(hSdio, CSL_SDIO_ENDIAN_LITTLE,
                                        CSL_SDIO_ENDIAN_LITTLE);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga72157ae53ee109f587b92e21afb3baae"></a><!-- doxytag: member="csl_sdio.h::SDIO_writeBlocks" ref="ga72157ae53ee109f587b92e21afb3baae" args="(CSL_SdioHandle hSdio, Uint32 writeAddr, Uint8 funNum, Bool opCode, Uint16 noOfBlocks, Uint16 blockSize, Uint16 *pWriteBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_writeBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>writeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>funNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>opCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>noOfBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pWriteBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_writeBlocks</b> </p>
<p><b>Description</b> <br/>
 This function writes requested number of blocks of data to SDIO card. 'writeAddr' is address on the SDIO card from where the writing starts. Block size of IO function to write data should be configured before calling this function.</p>
<p>Writing of data can be done to a fixed address(opCode = 0) or incrementing address(opCode = 1). Fixed mode data write is useful when I/O data is transferred using a FIFO inside SDIO card. Opcode should be 1 for the SDIO cards which doesn't have support for FIFO.</p>
<p>NOTE: Endian mode of the data transfer depends on the parameter 'writeEndianMode' in the SDIO handle. Default value for the endian mode is 'LITTLE ENDIAN' which will be set during SDIO open. Endian mode can be configured using <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaac86fe23943b0704aabbabd0b52c487d">SDIO_setEndianMode()</a>. DO NOT CHANGE THE ENDIAN MODE WITH OUT USING THIS API.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            writeAddr      Location to write to.
            funNum         IO function number to write data
            opCode         Bit to decide destination address mode
                             - Fixed/Incrementing
            noOfBlocks     Number of blocks to write.
            blockSize      Size of each block
            pWriteBuf      Pointer to write buffer.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Writes data to the SDIO card</p>
<p><b>Modifies</b> <br/>
 Data registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint32                   ocr;
            Uint16                   writeBuf[512];
            Uint32                   writeAddr;
            Uint16                   noOfBlocks;
            Bool                     opCode;
            Uint8                    funNum;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            status = SDIO_initCard(hSdio, ocr, TRUE);

            writeAddr  = 0x110;
            noOfBlocks = 2;
            opCode     = 1;
            funNum     = 0;

            status = SDIO_writeBlocks(hSdio, writeAddr, funNum, opCode,
                                      noOfBlocks, 256, writeBuf);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga5d463e7e61b5ba8937592bf5208b84b1"></a><!-- doxytag: member="csl_sdio.h::SDIO_writeBytes" ref="ga5d463e7e61b5ba8937592bf5208b84b1" args="(CSL_SdioHandle hSdio, Uint32 writeAddr, Uint8 funNum, Bool opCode, Uint16 noOfBytes, Uint16 *pWriteBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_writeBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>writeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>funNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>opCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>noOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pWriteBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_writeBytes</b> </p>
<p><b>Description</b> <br/>
 This function writes requested number of bytes to the SDIO card. 'writeAddr' is address on the SDIO card from where the writing starts. Maximum length of the data that can be written using this function is 512 bytes.</p>
<p>Writing of data can be done to a fixed address(opCode = 0) or incrementing address(opCode = 1). Fixed mode data write is useful when I/O data is transferred using a FIFO inside SDIO card. Opcode should be 1 for the SDIO cards which doesn't have support for FIFO.</p>
<p>NOTE: Endian mode of the data transfer depends on the parameter 'writeEndianMode' in the SDIO handle. Default value for the endian mode is 'LITTLE ENDIAN' which will be set during SDIO open. Endian mode can be configured using <a class="el" href="group__CSL__SDIO__FUNCTION.html#gaac86fe23943b0704aabbabd0b52c487d">SDIO_setEndianMode()</a>. DO NOT CHANGE THE ENDIAN MODE WITH OUT USING THIS API.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            writeAddr      Location to write to.
            funNum         IO function number to write data
            opCode         Bit to decide destination address mode
                             - Fixed/Incrementing
            noOfBytes      Number of bytes to write.
            pWriteBuf      Pointer to write buffer.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Writes data to the SDIO card</p>
<p><b>Modifies</b> <br/>
 Data registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint32                   ocr;
            Uint16                   writeBuf[512];
            Uint32                   writeAddr;
            Uint16                   noOfBytes;
            Bool                     opCode;
            Uint8                    funNum;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            status = SDIO_initCard(hSdio, ocr, TRUE);

            writeAddr  = 0x07;
            noOfBytes  = 1;
            opCode     = 1;
            funNum     = 0;

            status = SDIO_writeBytes(hSdio, writeAddr, funNum, opCode,
                                     noOfBytes, writeBuf);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga72f69500a0a64db9cb3029da7b676184"></a><!-- doxytag: member="csl_sdio.h::SDIO_writeSingleByte" ref="ga72f69500a0a64db9cb3029da7b676184" args="(CSL_SdioHandle hSdio, Uint32 writeAddr, Uint8 funNum, Uint8 writeData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDIO_writeSingleByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__SdioControllerObj.html">CSL_SdioHandle</a>&#160;</td>
          <td class="paramname"><em>hSdio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>writeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>funNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>writeData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SDIO_writeSingleByte</b> </p>
<p><b>Description</b> <br/>
 This function writes a single byte of data to the SDIO card. 'writeAddr' is address on the SDIO card to where data byte will be written. Command 52 (IO_RW_DIRECT Command) is used to write the data.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hSdio          Handle to the SDIO.
            writeAddr      Location to write data byte.
            funNum         IO function number to read data
            writeData      Data to be written
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_ESDIO_TIMEOUT - Card Response time out </li>
<li>CSL_ESDIO_CRCERR - Response/Data CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gaa45b55576f0863337fb9e984fab1d03f">SDIO_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__SDIO__FUNCTION.html#gae5f1f0eb79e89a68e959beed2579fa0a">SDIO_initCard()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Writes a byte of data to the SDIO card</p>
<p><b>Modifies</b> <br/>
 SDIO card registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_SdioControllerObj    sdioContObj;
            CSL_SdioHandle           hSdio;
            CSL_SdioInstId           instId;
            CSL_status               status;
            Uint16                   rca;
            Uint32                   ocr;
            Uint8                    writeData;
            Uint32                   writeAddr;
            Uint8                    funNum;

            instId = CSL_SDIO_INST0;

            status = SDIO_init();

            hSdio  = SDIO_open(&amp;sdioContObj, instId, &amp;status);

            status = SDIO_detectCard(hSdio, &amp;sdioCardObj);

            status = SDIO_initCard(hSdio, ocr, TRUE);

            writeAddr  = 0x02;
            writeData  = 0x02;
            funNum     = 0;

            status = SDIO_writeSingleByte(hSdio, writeAddr, funNum, writeData);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 27 2013 13:32:43 for C55XX CSL LP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
