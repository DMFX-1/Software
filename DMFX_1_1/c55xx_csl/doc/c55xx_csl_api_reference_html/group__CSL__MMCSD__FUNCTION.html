<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>C55XX CSL LP: MMC/SD Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">C55XX CSL LP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MMC/SD Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__CSL__MMCSD__API.html">MMCSD</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaaf5230667e9cde16496d716c5b5fd14f">MMC_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MMCControllerObj</a> *pMmcsdContObj, <a class="el" href="group__CSL__MMCSD__ENUM.html#gae4058f773c9cc4adc86d490cac7267b3">CSL_MmcsdInstId</a> instId, <a class="el" href="group__CSL__MMCSD__ENUM.html#gae6360eb80b01a15bae49ca23e73b5743">CSL_MMCSDOpMode</a> opMode, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3d40be0282818757b7e0db8a16ee828f">MMC_close</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga78aad8f81a6cb388dff08240e39fc018">MMC_setCardType</a> (<a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *pCardObj, <a class="el" href="group__CSL__MMCSD__ENUM.html#ga90fae15acd7c0ccde7119b9e47ec7a76">CSL_CardType</a> cardType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga96a951e3a784d66d98977177b0924959">MMC_setCardPtr</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *pMmcCardObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gae1470b3d6a92e29588d52deb2b9673f5">MMC_setCallBack</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCallBackObj.html">CSL_MMCCallBackObj</a> *pFunction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga01b5cd5567e2e2be698da24efab4637b">MMC_getNumberOfCards</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint16 *pActiveNoCard)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga5eaec80cbfae5e621bdd8750ee60b99d">MMC_clearResponse</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga7cd956aaeb7d25d93c8612a0d4e522f3">MMC_intEnable</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint16 maskValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga53ff2e72b087a62e027255664bb063dc">MMC_eventEnable</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group__CSL__MMCSD__ENUM.html#ga33f695a70a63561f62c30b8de50618c8">CSL_MMCSDEventType</a> mmcsdEvent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac7c8fb4a9c423667209fcda1ab640aa9">MMC_eventDisable</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group__CSL__MMCSD__ENUM.html#ga33f695a70a63561f62c30b8de50618c8">CSL_MMCSDEventType</a> mmcsdEvent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gafb6e3159e8d4883b1a23f57092e5cca8">MMC_drrdy</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, CSL_Status *pStatus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaa9c8982f625755a3a91bb05776aba551">MMC_dxrdy</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, CSL_Status *pStatus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga05378697af9598064568483c00c30f9c">MMC_saveStatus</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga39ea09951c9fe728ec28d3c9b9978526">MMC_getStatus</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint32 maskValue, CSL_Status *pStatus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga64755486e84519aceab8f6611c76bce8">MMC_setupNative</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCSetupNative.html">CSL_MMCSetupNative</a> *pMmcInit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaa0b0ed82c16b1c60be66dac250df513d">MMC_config</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCConfig.html">CSL_MMCConfig</a> *pMmcConfig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga5516a6aa18a9747847f658099349d429">MMC_getConfig</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCConfig.html">CSL_MMCConfig</a> *pMmcConfig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga66fa12d1e3126f4b5fbee1327381f87c">MMC_sendCmd</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint32 cmd, Uint32 arg, Uint16 eventFlags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga7819c9f81a2db4e17d5001e6bab9774f">MMC_sendGoIdle</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gab31b48d48ffc562e53f94c81c1ad6613">MMC_stop</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gad863c45cd0ae47cb96b5a235c4159195">MMC_deselectCard</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *pMmcCardObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *pMmcCardObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint16 clkDivValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga126887ca3952a6130e4957846c26ac68">MMC_setRca</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *pMmcCardObj, Uint16 rCardAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga422c250e5c38131c42df668587162eb7">SD_sendRca</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *pSdCardObj, Uint16 *pRCardAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga4b1a903e9a756253ff1cc15130f08eb3">MMC_sendAllCID</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardIdObj.html">CSL_MMCCardIdObj</a> *pMmcCardIdObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaffe121b613eb075a564f8f827d1b22fa">SD_sendAllCID</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardIdObj.html">CSL_MMCCardIdObj</a> *pSdCardIdObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga0ab342afd3a8406390cab83fbcd2a720">MMC_getCardCsd</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardCsdObj.html">CSL_MMCCardCsdObj</a> *pMmcCardCsdObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3a7183e22e839d1f57f6d143ce78c3a4">SD_getCardCsd</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardCsdObj.html">CSL_MMCCardCsdObj</a> *pSdCardCsdObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gad0130ec2b49dbd60cedc5bdb4b4a0d48">MMC_read</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint32 cardAddr, Uint16 noOfBytes, Uint16 *pReadBuffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga7f52bd655086f5a0d406d431c020f0a4">MMC_write</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint32 cardAddr, Uint16 noOfBytes, Uint16 *pWriteBuffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga9cabd2c2de7225dd78daa2387bf8aed4">MMC_setDmaHandle</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__DMA__ChannelObj.html">CSL_DMA_Handle</a> hDmaWrite, <a class="el" href="structCSL__DMA__ChannelObj.html">CSL_DMA_Handle</a> hDmaRead)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaf3d12f302957fef49d39a7ec849ca0da">MMC_setDataTransferCallback</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group__CSL__MMCSD__DATASTRUCT.html#ga996256ad667c6afe44badfd5b535ade2">CSL_MMCDataTxferCallBackPtr</a> dataTransferCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga352c10b5cb98c67b2edcaca9a527d496">MMC_setDmaChanConfig</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MmcsdDmaConfig.html">CSL_MmcsdDmaConfig</a> dmaConfig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3be5dcff1884f09477361fe4fd9f57e8">MMC_setEndianMode</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group__CSL__MMCSD__ENUM.html#gad374520910fa2c1324dc36d2ae22fa7d">CSL_MmcsdEndianMode</a> writeEndianMode, <a class="el" href="group__CSL__MMCSD__ENUM.html#gad374520910fa2c1324dc36d2ae22fa7d">CSL_MmcsdEndianMode</a> readEndianMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga092ceb666b92ba2d19946c827a6b35de">MMC_setBlockLength</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint32 blockLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga8911fdaf15d677af8c31463963c222a4">MMC_setWriteBlkEraseCnt</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint32 blkCnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac5311523eff70c1d40ff9e3947c57fab">SD_setBusWidth</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint8 busWidth)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga22902645c02da20730be0121cc9f623f">MMC_getCardStatus</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint32 *pCardStatus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gadff5ef92220929877229fddea116db6d">SD_configurePullup</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Bool pullupCfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gacf88c714a64d95d1472a56529921915c">MMC_enableBootPartitionAccess</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint8 partition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the access for the boot partition of eMMC card.  <a href="#gacf88c714a64d95d1472a56529921915c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga646580661159e4edf15075b655ed6cea">MMC_disableBootPartitionAccess</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the access for the boot partition of eMMC card.  <a href="#ga646580661159e4edf15075b655ed6cea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaa49525f3ea1088362501d3078464f947">MMC_bootPartitionEnable</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint8 partition, Bool bootAck)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the boot parition of the eMMC card for boot mode.  <a href="#gaa49525f3ea1088362501d3078464f947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaf7cf523965bd55c72f749c1c13726568">MMC_bootPartitionDisable</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the boot parition of the eMMC card for boot mode.  <a href="#gaf7cf523965bd55c72f749c1c13726568"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gae274ce72051283a596749b055ea5cd2d">MMC_sendSwitchCmd</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Uint32 argument)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends switch commmand to eMMC card.  <a href="#gae274ce72051283a596749b055ea5cd2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga6ce71027860acfef848f48334d9be540">MMC_enableBootMode</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Boot mode for eMMC card.  <a href="#ga6ce71027860acfef848f48334d9be540"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga66e467e16fbdb3ab95336e1a628cdaea">MMC_getBootPartitionSize</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Boot size of the eMMC card.  <a href="#ga66e467e16fbdb3ab95336e1a628cdaea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga1658e5a530ffce50f24ebd0c2a70cb60">MMC_setBootBusWidth</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group__CSL__MMCSD__ENUM.html#ga6dd64c9f21aa32b820c9b626c1792191">CSL_MmcsdBootBusWidth</a> bootBusWidth, Bool resetBusWidth)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the boot bus width.  <a href="#ga1658e5a530ffce50f24ebd0c2a70cb60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga44689a2b2eddefa622a8bbe1002b7b60">MMC_getCardExtCsd</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MMCCardExtCsdObj.html">CSL_MMCCardExtCsdObj</a> *pMmcsdCardExtCSD)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga770b1ccb0e958bf9ce380bd3e8f71ed7">sendCmd</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="structCSL__MmcsdCmd.html">CSL_MmcsdCmd</a> *cmd, Uint32 argument)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends command.  <a href="#ga770b1ccb0e958bf9ce380bd3e8f71ed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gada1f8f1c1fa95145770944ec6bb58307">MMC_setEMMCBusWidth</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd, Bool busWidth)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bus width.  <a href="#gada1f8f1c1fa95145770944ec6bb58307"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaf546ca16367d88a3272acded29ac531d">MMC_initCtrl</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize MMC controller.  <a href="#gaf546ca16367d88a3272acded29ac531d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3fcc64e97de81a7fa6d15e335580f47f">MMC_configFifo</a> (<a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the MMC/SD Fifo.  <a href="#ga3fcc64e97de81a7fa6d15e335580f47f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga4a124fb564fdc4f89e38cd751dbac170">MMC_initState</a> (AtaState *pDrive)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga82778fe9313e874740bcd78a3f070cf8">MMC_issueReadCommand</a> (AtaSector phySector, void *pAtaMediaState, AtaUint16 sectorCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac33a4b6e29921e909ba63fbf23aaca6e">MMC_readNextWord</a> (void *pAtaMediaState, AtaUint16 *pWord)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga8ccf47efae5b6671edfb4e50715e128b">MMC_readNextWord1</a> (void *pAtaMediaState, AtaUint16 *pWord, AtaUint16 word_delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga42474102f50665ea6e3e0b909e0b6957">MMC_readNextNWords</a> (void *pAtaMediaState, AtaUint16 *pData, AtaUint16 words)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gad904a36b62dff38809b18706f2b217a8">MMC_writeSector</a> (AtaSector phySector, void *pAtaMediaState, AtaUint16 *pWord, int byteSwap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga52ba79b3047d32681fd2f3e507df2792">MMC_readNSectors</a> (void *pAtaMediaState, AtaUint16 *pReadBuf, AtaSector startSector, AtaUint16 sectorCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga1ce2cec113d65fdb5a88bdd6f462e330">MMC_writeNSectors</a> (void *pAtaMediaState, AtaUint16 *pWriteBuf, AtaSector startSector, AtaUint16 sectorCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3b287854bf37514bd37abbfc5eb6d278">MMC_read_CID</a> (void *pAtaMediaState, unsigned int *pBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gad815e54ad246ae449a41e7b4c7e7665b">MMC_read_CSD</a> (void *pAtaMediaState, unsigned int *pBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga387ce86f026b4c9a65f057bd0d4bf0dc">MMC_writeSectorFlush</a> (void *pAtaMediaState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga002536f323acd8cdcecad9173bb2663a">MMC_commandReadyStatusCheck</a> (void *pAtaMediaState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gad12d09d9b9660efa91fe5c7f7ed1352c">MMC_dataReadyStatusCheck</a> (void *pAtaMediaState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaf98518d61cbf3f71d490016ca130f890">MMC_busyStatusCheck</a> (void *pAtaMediaState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaf582af3048a97a1354accc831339d7a2">MMC_getSerialID</a> (void *pAtaMediaState, AtaSerialID *pSerID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga26f99b002a33a81075edf1fd77ee6aa4">MMC_file_system_format</a> (void *pAtaMediaState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gafd44c2a140fd9eb1c97e623515b256aa">MMC_reset</a> (void *pAtaMediaState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2c89af9f936bf0bd0ca53585406e4a7b">MMC_get_time</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gae05d86cbca3a1aaacc03fda968bfc15d">MMC_get_mod_time</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga925e89ab4b717172b1a2ef7dbdf40b2b">MMC_get_date</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gab0a34021ba2878cb90c65d894a6c9d5c">MMC_get_mod_date</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga1a0cb92aff7fccadf76863408e31fd91">MMC_flushFat</a> (void *pAtaMediaState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__MMCSD__FUNCTION.html#gab8503707f26c8dd958ca6738106032f4">getAtaErrorNo</a> (CSL_Status result)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab8503707f26c8dd958ca6738106032f4"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::getAtaErrorNo" ref="gab8503707f26c8dd958ca6738106032f4" args="(CSL_Status result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static AtaError getAtaErrorNo </td>
          <td>(</td>
          <td class="paramtype">CSL_Status&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>getAtaErrorNo</b> </p>
<p><b>Description</b> <br/>
 This function checks the return value send by the MMCSD CSL module and returns the corresponding error value to the ATA File system. This function is called in case of any error occurred</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            result    Result returned by the CSL MMCSD module
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Returns ATA Error codes</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_Status    result;
            AtaError      ataErr;

            result = MMC_init();

            ataErr = getAtaErrorNo(result);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaf7cf523965bd55c72f749c1c13726568"></a><!-- doxytag: member="csl_mmcsd.h::MMC_bootPartitionDisable" ref="gaf7cf523965bd55c72f749c1c13726568" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_bootPartitionDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables the boot parition of the eMMC card for boot mode. </p>
<p>This API disables the boot mode for the boot area partition</p>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gaa49525f3ea1088362501d3078464f947"></a><!-- doxytag: member="csl_mmcsd.h::MMC_bootPartitionEnable" ref="gaa49525f3ea1088362501d3078464f947" args="(CSL_MmcsdHandle hMmcsd, Uint8 partition, Bool bootAck)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_bootPartitionEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>bootAck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables the boot parition of the eMMC card for boot mode. </p>
<p>This API configures the boot partition from which boot data is read during boot operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">partition</td><td>[IN] Partition number for which boot enable is required 1 - Enable the boot for partition 1 2 - Enable the boot for partition 2 </td></tr>
    <tr><td class="paramname">bootAck</td><td>[IN] Request for acknowledgement during boot mode 0 - Card will not send acknowldgement pattern during boot 1 - Card sends acknowldgement pattern during boot</td></tr>
  </table>
  </dd>
</dl>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gaf98518d61cbf3f71d490016ca130f890"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_busyStatusCheck" ref="gaf98518d61cbf3f71d490016ca130f890" args="(void *pAtaMediaState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_busyStatusCheck </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_busyStatusCheck</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;

			pAtaState = &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaBusyStatusCheck(ataState-&gt;pAtaMediaState);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga5eaec80cbfae5e621bdd8750ee60b99d"></a><!-- doxytag: member="csl_mmcsd.h::MMC_clearResponse" ref="ga5eaec80cbfae5e621bdd8750ee60b99d" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_clearResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_clearResponse</b> </p>
<p><b>Description</b> <br/>
 This function clears all eight response registers of MMCSD.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd    Handle to the MMCSD
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully before this.</p>
<p><b> Post Condition </b> <br/>
 Clears response</p>
<p><b>Modifies</b> <br/>
 MMCSD Response Registers.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_clearResponse(hMmcsd);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga3d40be0282818757b7e0db8a16ee828f"></a><!-- doxytag: member="csl_mmcsd.h::MMC_close" ref="ga3d40be0282818757b7e0db8a16ee828f" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_close</b> </p>
<p><b>Description</b> <br/>
 This function closes the specified handle to MMCSD.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd    Handle to the MMCSD
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully before this.</p>
<p><b> Post Condition </b> <br/>
 Closes the MMC handle</p>
<p><b>Modifies</b> <br/>
 MMCSD handle will be assigned to NULL.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_close(hMmcsd);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga002536f323acd8cdcecad9173bb2663a"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_commandReadyStatusCheck" ref="ga002536f323acd8cdcecad9173bb2663a" args="(void *pAtaMediaState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MMC_commandReadyStatusCheck </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_commandReadyStatusCheck</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			int            status;

			pAtaState = &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            status = pAtaState-&gt;AtaCommandReadyStatusCheck(ataState-&gt;pAtaMediaState);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaa0b0ed82c16b1c60be66dac250df513d"></a><!-- doxytag: member="csl_mmcsd.h::MMC_config" ref="gaa0b0ed82c16b1c60be66dac250df513d" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCConfig *pMmcConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCConfig.html">CSL_MMCConfig</a> *&#160;</td>
          <td class="paramname"><em>pMmcConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_config</b> </p>
<p><b>Description</b> <br/>
 Function to configure the MMCSD registers. Register configuration will be done as per the configuration parameters passed to the function.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd        Handle to the MMCSD.
            pMmcConfig    Pointer to the MMCSD config parameter.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 MMCSD Register will be populated.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle       hMmcsd;
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            CSL_MMCConfig         mmcConfig;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            Note: CSL_MMCConfig field are following.
			mmcConfig.mmcblen = CSL_MMCSD_BLOCK_LENGTH;
			mmcConfig.mmcclk  = 0x10 |CSL_MMCSD_MMCCLK_CLKEN_ENABLE;
			mmcConfig.mmcctl  = CSL_MMCSD_MMCCTL_DATEG_F_EDGE;
			mmcConfig.mmcim   = 0x0;
			mmcConfig.mmcnblk = 0x1;
			mmcConfig.mmctod  = CSL_MMCSD_DATA_RW_TIMEOUT;
			mmcConfig.mmctor  = CSL_MMCSD_RESPONSE_TIMEOUT;

            status = MMC_config(hMmcsd, &amp;mmcConfig);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga3fcc64e97de81a7fa6d15e335580f47f"></a><!-- doxytag: member="csl_mmcsd.h::MMC_configFifo" ref="ga3fcc64e97de81a7fa6d15e335580f47f" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_configFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the MMC/SD Fifo. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gad12d09d9b9660efa91fe5c7f7ed1352c"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_dataReadyStatusCheck" ref="gad12d09d9b9660efa91fe5c7f7ed1352c" args="(void *pAtaMediaState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_dataReadyStatusCheck </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_dataReadyStatusCheck</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;

			pAtaState = &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaDataReadyStatusCheck(ataState-&gt;pAtaMediaState);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gad863c45cd0ae47cb96b5a235c4159195"></a><!-- doxytag: member="csl_mmcsd.h::MMC_deselectCard" ref="gad863c45cd0ae47cb96b5a235c4159195" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardObj *pMmcCardObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_deselectCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_deselectCard</b> </p>
<p><b>Description</b> <br/>
 This function will send command for deselecting particular card which is assigned in card object.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD.
            pMmcCardObj       Pointer to the MMCSD Card Info.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this. <br/>
 RCA value should be properly stored in handle hMmcsd.</p>
<p><b> Post Condition </b> <br/>
 Deselects the card</p>
<p><b>Modifies</b> <br/>
 MMCSD card object structure.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MMCCardObj          mmcCardObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_deselectCard(hMmcsd, &amp;mmcCardObj);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga646580661159e4edf15075b655ed6cea"></a><!-- doxytag: member="csl_mmcsd.h::MMC_disableBootPartitionAccess" ref="ga646580661159e4edf15075b655ed6cea" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_disableBootPartitionAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables the access for the boot partition of eMMC card. </p>
<p>After sucessful execution of this API, access to eMMC boot partition is not allowed</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gafb6e3159e8d4883b1a23f57092e5cca8"></a><!-- doxytag: member="csl_mmcsd.h::MMC_drrdy" ref="gafb6e3159e8d4883b1a23f57092e5cca8" args="(CSL_MmcsdHandle hMmcsd, CSL_Status *pStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool MMC_drrdy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_drrdy</b> </p>
<p><b>Description</b> <br/>
 This function returns data receive ready status. Value returned by this API is useful to decide whether data is available in MMC/SD controller FIFO for reading or not.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd     Handle to the MMCSD
            pStatus    Status of API success or failed.
     </pre></div><p><b> Return Value </b> Bool </p>
<ul>
<li>TRUE - Data is available for reading </li>
<li>FALSE - Data is not available for reading</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            Bool                  drrdyStatus;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            drrdyStatus = MMC_drrdy(hMmcsd, &amp;status);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaa9c8982f625755a3a91bb05776aba551"></a><!-- doxytag: member="csl_mmcsd.h::MMC_dxrdy" ref="gaa9c8982f625755a3a91bb05776aba551" args="(CSL_MmcsdHandle hMmcsd, CSL_Status *pStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool MMC_dxrdy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_dxrdy</b> </p>
<p><b>Description</b> <br/>
 This function returns data transmit ready status. Value returned by this API is useful to decide whether data can be written to MMCSD controller FIFO or not.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd     Handle to the MMCSD
            pStatus    Status of API success or failed
     </pre></div><p><b> Return Value </b> Bool </p>
<ul>
<li>TRUE - MMCSD FIFO is ready to accept data </li>
<li>FALSE - MMCSD FIFO is not ready to accept data</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            Bool                  dxrdyStatus;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            dxrdyStatus = MMC_dxrdy(hMmcsd, &amp;status);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga6ce71027860acfef848f48334d9be540"></a><!-- doxytag: member="csl_mmcsd.h::MMC_enableBootMode" ref="ga6ce71027860acfef848f48334d9be540" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_enableBootMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables the Boot mode for eMMC card. </p>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gacf88c714a64d95d1472a56529921915c"></a><!-- doxytag: member="csl_mmcsd.h::MMC_enableBootPartitionAccess" ref="gacf88c714a64d95d1472a56529921915c" args="(CSL_MmcsdHandle hMmcsd, Uint8 partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_enableBootPartitionAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables the access for the boot partition of eMMC card. </p>
<p>After sucessful execution of this API, it is possible to write/read boot partition of the eMMC card with normal MMC commands</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">partition</td><td>[IN] Partition number for which boot access needs to be enabled 1 - Enable the access for boot partition 1 2 - Enable the access for boot partition 2</td></tr>
  </table>
  </dd>
</dl>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gac7c8fb4a9c423667209fcda1ab640aa9"></a><!-- doxytag: member="csl_mmcsd.h::MMC_eventDisable" ref="gac7c8fb4a9c423667209fcda1ab640aa9" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCSDEventType mmcsdEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_eventDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__ENUM.html#ga33f695a70a63561f62c30b8de50618c8">CSL_MMCSDEventType</a>&#160;</td>
          <td class="paramname"><em>mmcsdEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_eventDisable</b> </p>
<p><b>Description</b> <br/>
 This function disables the MMC events depending on the 'mmcsdEvent' passed as a parameter. This function is useful to disable single interrupt of MMC interrupt mask register in one function call.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd        Handle to the MMCSD
            mmcsdEvent    Event type.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
</p>
<p><b>Modifies</b> <br/>
 Interrupt will be disabled for particular event.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_MMCSDEventType    mmcsdEvent;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);
            mmcsdEvent = CSL_MMCSD_EDATDNE_INTERRUPT;

            status = MMC_eventDisable(hMmcsd, mmcsdEvent);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga53ff2e72b087a62e027255664bb063dc"></a><!-- doxytag: member="csl_mmcsd.h::MMC_eventEnable" ref="ga53ff2e72b087a62e027255664bb063dc" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCSDEventType mmcsdEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_eventEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__ENUM.html#ga33f695a70a63561f62c30b8de50618c8">CSL_MMCSDEventType</a>&#160;</td>
          <td class="paramname"><em>mmcsdEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_eventEnable</b> </p>
<p><b>Description</b> <br/>
 This function enables the MMC events depending on the 'mmcsdEvent' passed as a parameter. This function is useful to enable single interrupt of MMC interrupt mask register in one function call.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd        Handle to the MMCSD
            mmcsdEvent    Event type.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. Before enabling interrupt of any type make sure the isr function is plugged in ISR.</p>
<p><b> Post Condition </b> <br/>
 Interrupt will be enabled for particular event.</p>
<p><b>Modifies</b> <br/>
 MMC interrupt mask register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_MMCSDEventType    mmcsdEvent;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);
            eventType = CSL_MMCSD_EDATDNE_INTERRUPT;

            status = MMC_eventEnable(hMmcsd, mmcsdEvent);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga26f99b002a33a81075edf1fd77ee6aa4"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_file_system_format" ref="ga26f99b002a33a81075edf1fd77ee6aa4" args="(void *pAtaMediaState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_file_system_format </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_file_system_format</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaUint16      retVal;

			pAtaState = &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            retVal = pAtaState-&gt;AtaFileSystemType(ataState-&gt;pAtaMediaState);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga1a0cb92aff7fccadf76863408e31fd91"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_flushFat" ref="ga1a0cb92aff7fccadf76863408e31fd91" args="(void *pAtaMediaState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_flushFat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_flushFat</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;

			pAtaState = *ataState;
			pAtaState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaFlushFat(pAtaState-&gt;pAtaMediaState);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga925e89ab4b717172b1a2ef7dbdf40b2b"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_get_date" ref="ga925e89ab4b717172b1a2ef7dbdf40b2b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_get_date </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_get_date</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            None
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaUint16      date;

			pAtaState = &amp;ataState;

			ataErr = MMC_initState(&amp;ataState);

            date   = pAtaState-&gt;get_date();

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gab0a34021ba2878cb90c65d894a6c9d5c"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_get_mod_date" ref="gab0a34021ba2878cb90c65d894a6c9d5c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_get_mod_date </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_get_mod_date</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            None
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaUint16      date;

			pAtaState = &amp;ataState;

			ataErr = MMC_initState(&amp;ataState);

            date   = pAtaState-&gt;get_mod_date();

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gae05d86cbca3a1aaacc03fda968bfc15d"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_get_mod_time" ref="gae05d86cbca3a1aaacc03fda968bfc15d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_get_mod_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_get_mod_time</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            None
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaUint16      time;

			pAtaState = &amp;ataState;

			ataErr = MMC_initState(&amp;ataState);

            time   = pAtaState-&gt;get_mod_time();

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga2c89af9f936bf0bd0ca53585406e4a7b"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_get_time" ref="ga2c89af9f936bf0bd0ca53585406e4a7b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_get_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_get_time</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            None
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaUint16      time;

			pAtaState = &amp;ataState;

			ataErr = MMC_initState(&amp;ataState);

            time   = pAtaState-&gt;get_time();

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga66e467e16fbdb3ab95336e1a628cdaea"></a><!-- doxytag: member="csl_mmcsd.h::MMC_getBootPartitionSize" ref="ga66e467e16fbdb3ab95336e1a628cdaea" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MMC_getBootPartitionSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Boot size of the eMMC card. </p>
<p>This API decodes the csd and gets the Boot size of the card</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Uint32 - Size of boot partition </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ab342afd3a8406390cab83fbcd2a720"></a><!-- doxytag: member="csl_mmcsd.h::MMC_getCardCsd" ref="ga0ab342afd3a8406390cab83fbcd2a720" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardCsdObj *pMmcCardCsdObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getCardCsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardCsdObj.html">CSL_MMCCardCsdObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardCsdObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_getCardCsd</b> </p>
<p><b>Description</b> <br/>
 This function will update the CSD Structure information of MMC Card.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD.
            pMmcCardCsdObj    Pointer to the MMC Card CSD Info.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1. <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br/>
 2. <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br/>
 3. if Card detected is MMC then <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to MMC.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 CSD object structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MMCCardObj          mmcCardObj;
            CSL_MMCCardCsdObj       mmcCardCsdObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint16                  clkDivValue;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

            clkDivValue = 0x4 //as MMC clock max is 20MHz and
                                Function clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);

            status = MMC_getCardCsd(hMmcsd, &amp;mmcCardCsdObj);

            For example following value will be populated.
            pMmcCardCsdObj-&gt;readBlLen         = ;
            pMmcCardCsdObj-&gt;cSize  = ;

            These value will be useful to fetch the card specific information
            as shown below. These figure are tested with 256Mbyte MMC Card

            blockLength  = 512 Bytes
            cardCapacity = 0x260636672 Bytes
            totalSectors = 0x509056 sector

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga44689a2b2eddefa622a8bbe1002b7b60"></a><!-- doxytag: member="csl_mmcsd.h::MMC_getCardExtCsd" ref="ga44689a2b2eddefa622a8bbe1002b7b60" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardExtCsdObj *pMmcsdCardExtCSD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getCardExtCsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardExtCsdObj.html">CSL_MMCCardExtCsdObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcsdCardExtCSD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_getCardExtCsd</b> </p>
<p><b>Description</b> <br/>
 Reads extended CSD strcuture of eMMC card</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd              Handle to the MMCSD.
            pMmcsdCardExtCSD    Pointer to the MMC Card extended CSD Info.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1. <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br/>
 2. <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br/>
 3. if Card detected is MMC then <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to MMC.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 CSD object structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MMCCardObj          mmcCardObj;
            CSL_MMCCardExtCsdObj    mmcCardExtCsdObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint16                  clkDivValue;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

            clkDivValue = 0x4 //as MMC clock max is 20MHz and
                                Function clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);

            status = MMC_getCardExtCsd(hMmcsd, &amp;mmcCardExtCsdObj);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga22902645c02da20730be0121cc9f623f"></a><!-- doxytag: member="csl_mmcsd.h::MMC_getCardStatus" ref="ga22902645c02da20730be0121cc9f623f" args="(CSL_MmcsdHandle hMmcsd, Uint32 *pCardStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getCardStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pCardStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_getCardStatus</b> </p>
<p><b>Description</b> <br/>
 Function to get the status of the memory card. This function sends CMD13 to memory card to get the status. Memory card status will have the useful information to determine the card status and errors if any occurred. Refer to MMC/SD specification for the details of fields contained in the MMC/SD status.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd         MMCSD handle
            pCardStatus    Pointer to store the status sent by the card
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Gets card status</p>
<p><b>Modifies</b> <br/>
 Card status pointer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MmcsdHandle         hMmcsd;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint32                  cardStatus;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);

            status = MMC_getCardStatus(hMmcsd, &amp;cardStatus);
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga5516a6aa18a9747847f658099349d429"></a><!-- doxytag: member="csl_mmcsd.h::MMC_getConfig" ref="ga5516a6aa18a9747847f658099349d429" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCConfig *pMmcConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCConfig.html">CSL_MMCConfig</a> *&#160;</td>
          <td class="paramname"><em>pMmcConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_getConfig</b> </p>
<p><b>Description</b> <br/>
 This function will fetch the information present in the MMCSD registers and update to passed the config parameter.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd        Handle to the MMCSD.
            pMmcConfig    Pointer to the MMCSD config Parameter.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle       hMmcsd;
			CSL_MMCControllerObj  pMmcsdContObj;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            CSL_MMCConfig         pMmcConfig)

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_getConfig(hMmcsd, &amp;pMmcConfig);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga01b5cd5567e2e2be698da24efab4637b"></a><!-- doxytag: member="csl_mmcsd.h::MMC_getNumberOfCards" ref="ga01b5cd5567e2e2be698da24efab4637b" args="(CSL_MmcsdHandle hMmcsd, Uint16 *pActiveNoCard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getNumberOfCards </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pActiveNoCard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_getNumberOfCards</b> </p>
<p><b>Description</b> <br/>
 Get the number of cards information from the MMC handler.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd           Handle to the MMCSD
            pActiveNoCard    pointer to store number of active card info.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            Uint16                activeNoCard;
            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;
            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_getNumberOfCards(hMmcsd, &amp;activeNoCard);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaf582af3048a97a1354accc831339d7a2"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_getSerialID" ref="gaf582af3048a97a1354accc831339d7a2" args="(void *pAtaMediaState, AtaSerialID *pSerID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_getSerialID </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaSerialID *&#160;</td>
          <td class="paramname"><em>pSerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_getSerialID</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
            pID               Pointer to store the serial Id
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaSerialID    serId;

			pAtaState= &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            retVal = pAtaState-&gt;AtaGetSerialID(ataState-&gt;pAtaMediaState,
                                               &amp;serId);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga39ea09951c9fe728ec28d3c9b9978526"></a><!-- doxytag: member="csl_mmcsd.h::MMC_getStatus" ref="ga39ea09951c9fe728ec28d3c9b9978526" args="(CSL_MmcsdHandle hMmcsd, Uint32 maskValue, CSL_Status *pStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MMC_getStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>maskValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_getStatus</b> </p>
<p><b>Description</b> <br/>
 This function return the status of particular field of MMCST0 and MMCST1 register according to the passed mask value. Value of MMCST1 will be stored in upper 16 bits and value of MMCST0 will be stored in lower 16 bits of the returned value.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd       Handle to the MMCSD
            maskValue    Mask value to specify the field.
            pStatus      Status of API success or failed.
     </pre></div><p><b> Return Value </b> Uint32 </p>
<ul>
<li>status - MMCST0 and MMCST1 register value.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            Uint16                maskValue;
            CSL_status            status;
            Uint32                mmcStatus;
            Uint32                maskValue;

            instId = CSL_MMCSD0_INST;
            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

			// Get the value of mmcst0 register
            maskValue = 0x0000FFFF;

            mmcStatus = MMC_getStatus(hMmcsd, maskValue, &amp;status);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaaf5230667e9cde16496d716c5b5fd14f"></a><!-- doxytag: member="csl_mmcsd.h::MMC_init" ref="gaaf5230667e9cde16496d716c5b5fd14f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_init</b> </p>
<p><b>Description</b> <br/>
 This is the initialization function for the MMCSD CSL. The function must be called before calling any other API from MMCSD CSL. This function is for enabling the clock to the MMCSD Controller and routing MMCSD pins to the external serial port. This function should be called only once during system initialization time. This function gates the clock for the two MMCSD modules. Application programs may disable the clocks for MMCSD module which is not in use.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - MMCSD initialization successfully</li>
</ul>
<p><b> Pre Condition </b> <br/>
 This should be call first before calling any other MMCSD Function.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_status       status;

            status = MMC_init();
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaf546ca16367d88a3272acded29ac531d"></a><!-- doxytag: member="csl_mmcsd.h::MMC_initCtrl" ref="gaf546ca16367d88a3272acded29ac531d" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_initCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize MMC controller. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a124fb564fdc4f89e38cd751dbac170"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_initState" ref="ga4a124fb564fdc4f89e38cd751dbac170" args="(AtaState *pDrive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_initState </td>
          <td>(</td>
          <td class="paramtype">AtaState *&#160;</td>
          <td class="paramname"><em>pDrive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_initState</b> </p>
<p><b>Description</b> <br/>
 This function initializes ATA state structure. Initializes all function pointers in the ATA state structure with appropriate function address. This function should be called by the application programs before transferring the control over the media to ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pDrive    ATA state structure pointer
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Initializes ATA state structure</p>
<p><b>Modifies</b> <br/>
 ATA state structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaState       ataState;
			AtaError       ataErr;

			ataErr = MMC_initState(&amp;ataState);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga7cd956aaeb7d25d93c8612a0d4e522f3"></a><!-- doxytag: member="csl_mmcsd.h::MMC_intEnable" ref="ga7cd956aaeb7d25d93c8612a0d4e522f3" args="(CSL_MmcsdHandle hMmcsd, Uint16 maskValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_intEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>maskValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_intEnable</b> </p>
<p><b>Description</b> <br/>
 This function will enable or disable interrupts for MMCSD depending on the passed mask value for interrupt. MMC interrupt mask register will be configured by this API. This function is useful to enable the multiple MMC interrupts in one function call.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd       Handle to the MMCSD
            maskValue    mask value to specify the interrupt state.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully before this. Before enabling interrupt of any type make sure the isr function is plugged in ISR.</p>
<p><b> Post Condition </b> <br/>
 Enables MMC interrupts</p>
<p><b>Modifies</b> <br/>
 MMC interrupt mask register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            Uint16                maskValue;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);
            NOTE: Use the bit mask values of MMCIM register defined
                  cslr_mmcsd.h file for making the mask value.

            maskValue = CSL_MMCSD_MMCIM_ETRNDNE_MASK |
                        CSL_MMCSD_MMCIM_EDATED_MASK;

            status = MMC_intEnable(hMmcsd, maskValue);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga82778fe9313e874740bcd78a3f070cf8"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_issueReadCommand" ref="ga82778fe9313e874740bcd78a3f070cf8" args="(AtaSector phySector, void *pAtaMediaState, AtaUint16 sectorCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_issueReadCommand </td>
          <td>(</td>
          <td class="paramtype">AtaSector&#160;</td>
          <td class="paramname"><em>phySector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>sectorCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_issueReadCommand</b> </p>
<p><b>Description</b> <br/>
 This function is used to fetch all normal data from the media. A sector is always assumed to be 256 16-bit words by the high-level API</p>
<p>Programs calling this function should assign proper value to ATA_No_Swap in case of using that varaible.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            phySector         Sector number from which data needs to be read
            pAtaMediaState    ATA media state structure
            sectorCount       Number of sectors to read
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Reads Data from MMC/SD card</p>
<p><b>Modifies</b> <br/>
 Global Read buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaSector      phySector;
			AtaUint16      sectCnt;

			pAtaState = &amp;ataState;

			phySector = 0;
			sectCnt   = 16;
			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaIssueReadCommand(phySector,
                                                    ataState-&gt;pAtaMediaState,
                                                    sectCnt);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gac69a19e39587bc4bc74144287050c64b"></a><!-- doxytag: member="csl_mmcsd.h::MMC_open" ref="gac69a19e39587bc4bc74144287050c64b" args="(CSL_MMCControllerObj *pMmcsdContObj, CSL_MmcsdInstId instId, CSL_MMCSDOpMode opMode, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a> MMC_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MMCControllerObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcsdContObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__ENUM.html#gae4058f773c9cc4adc86d490cac7267b3">CSL_MmcsdInstId</a>&#160;</td>
          <td class="paramname"><em>instId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__ENUM.html#gae6360eb80b01a15bae49ca23e73b5743">CSL_MMCSDOpMode</a>&#160;</td>
          <td class="paramname"><em>opMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_open</b> </p>
<p><b>Description</b> <br/>
 This function opens the CSL MMCSD module and returns handle to the MMCSD object structure. Parameter 'opMode' is provided to select the operating mode of the MMCSD module. Opmode information is stored in the MMCSD handle and is used in data transfer APIs.</p>
<p>NOTE: THIS API SETS THE ENDIAN MODE OF MMCSD READ AND WRITE OPERATIONS TO LITTLE ENDIAN. USE <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3be5dcff1884f09477361fe4fd9f57e8">MMC_setEndianMode()</a> TO CHANGE ENDIAN MODE.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pMmcsdContObj    MMCSD Controller object structure
            instId           Instance number for MMCSD
            opMode           Operating mode of the MMCSD module
            status           Status of the function call
     </pre></div><p><b> Return Value </b> CSL_MmmcsdHandle <br/>
 Valid MMCSD handle will be returned if status value is equal to CSL_SOK.</p>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gaaf5230667e9cde16496d716c5b5fd14f">MMC_init()</a> API should be called before <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a>.</p>
<p><b> Post Condition </b> <br/>
 1. The status is returned in the status variable. If status returned is </p>
<ul>
<li>CSL_SOK - Valid MMCSD handle is returned </li>
<li>CSL_ESYS_INVPARAMS - resource is already in use <br/>
 2. CSL_MmmcsdObj object structure is populated</li>
</ul>
<p><b>Modifies</b> <br/>
 1. The status variable <br/>
 2. CSL_MmmcsdObj object structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  pMmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;
            status =  MMC_init();
            hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gad0130ec2b49dbd60cedc5bdb4b4a0d48"></a><!-- doxytag: member="csl_mmcsd.h::MMC_read" ref="gad0130ec2b49dbd60cedc5bdb4b4a0d48" args="(CSL_MmcsdHandle hMmcsd, Uint32 cardAddr, Uint16 noOfBytes, Uint16 *pReadBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cardAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>noOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pReadBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_read</b> </p>
<p><b>Description</b> <br/>
 This function reads data from the memory card at a given address and populates the data to read buffer.</p>
<p>'cardAddr' represents the address location in the card to be accessed. For the standard capacity cards this parameter will be a value in multiples of 512. That means to read a sector number 1 cardAddr will be 1*512, to read a sector number 2 cardAddr will be 2*512 and so on. For the high capacity cards 'cardAddr' parameter will be same as the sector number. That means to read a sector number 1 cardAddr will be 1, to read a sector number 2 cardAddr will be 2 and so on. Reason for this is high capacity cards uses BLOCK addressing instead of the BYTE addressing used by the standard capacity cards to increase the addressable memory capacity.</p>
<p>Detection of high capacity cards can be verified using the flag 'sdHcDetected' in the MMCSD card object structure. sdHcDetected = TRUE - SD card is high capacity card sdHcDetected = FALSE - SD card is standard capacity card</p>
<p>NOTE: CARE SHOULD BE TAKEN WHILE PASSING THE 'cardAddr' PARAMETER. USING BYTE ADDRESSING WITH HIGH CAPACITY CARDS WILL LEAD TO OUT OF SECTOR BOUNDARY ACCESS AND RESULTS IN CODE HANGING FOR MMCSD RESPONSE.</p>
<p>NOTE: Endian mode of the data transfer depends on the parameter 'readEndianMode' in the MMC handle. Default value for the endian mode is 'LITTLE ENDIAN' which will be set during MMC open. Endian mode can be configured using <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3be5dcff1884f09477361fe4fd9f57e8">MMC_setEndianMode()</a>. DO NOT CHANGE THE ENDIAN MODE WITH OUT USING THIS API.</p>
<p>NOTE: When transferring data in DMA mode, word swap will be done for the data buffer when MMCSD is configured for little endian mode. No word swap is required in upper SW layers.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd         Handle to the MMCSD.
            cardAddr       Location to read from.
            noOfBytes      Number of bytes to read.
            pReadBuffer    Pointer to a buffer.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - card Response time out</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1. <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br/>
 2. <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br/>
 3. <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to card. <br/>
 4. If card detected is SD then call <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3a7183e22e839d1f57f6d143ce78c3a4">SD_getCardCsd()</a> specific to SD. If card detected is MMC then call <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga0ab342afd3a8406390cab83fbcd2a720">MMC_getCardCsd()</a> specific to MMC</p>
<p><b> Post Condition </b> <br/>
 Populates data to read buffer.</p>
<p><b>Modifies</b> <br/>
 Read data buffer.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle       hMmcsd;
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MMCCardObj        sdCardObj;
            CSL_MMCCardCsdObj     sdCardCsdObj;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            Uint16                clkDivValue;
            Uint16                noOfBytes;
            Uint16                cardAddr;
            Uint16                readBuffer[256];

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

            clkDivValue = 0x1 //as SD clock max is 50MHz and Function clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);

            status = SD_getCardCsd(hMmcsd, &amp;sdCardCsdObj);
            For example following value will be populated.
            sdCardCsdObj.readBlLen = ;
            sdCardCsdObj.cSize     = ;
            These values will be useful to fetch the card specific information
            like these-----
            These figure are tested with 1GB SD Card
            blockLength      = 512 Bytes
            cardCapacity     = 0x1015808000 Bytes
            totalSectors     = 0x1984000 sector

            cardAddr = 0x200;
            noOfBytes = 512;

            status = MMC_read(hMmcsd, cardAddr, noOfBytes, readBuffer);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga3b287854bf37514bd37abbfc5eb6d278"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_read_CID" ref="ga3b287854bf37514bd37abbfc5eb6d278" args="(void *pAtaMediaState, unsigned int *pBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_read_CID </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_read_CID</b> </p>
<p><b>Description</b> <br/>
 This function is used to read the MMCSD card identification information. CID information stored in the internal MMCSD handle is copied to the given data buffer. This function stores 8 words each of length 16bit into the given buffer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
            pBuf              Pointer to data buffer to store CID information
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_Open and MMC_sendAllCID/SD_sendAllCID APIs should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Writes CID data to given buffer</p>
<p><b>Modifies</b> <br/>
 Data in pBuf</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MMCControllerObj    pMmcsdContObj;
            CSL_MmcsdHandle 		mmcsdHandle;
            CSL_MMCCardIdObj 		sdCardIdObj;
			AtaMMCState             ataMediaState;
			AtaState                ataState;
			AtaError                ataErr;
			unsigned int            csdBuf[8];
			CSL_Status              status;

            ataState-&gt;pAtaMediaState = &amp;ataMediaState;

            //Open MMCSD module
	        mmcsdHandle = MMC_open(&amp;pMmcsdContObj, CSL_MMCSD0_INST,
	                               CSL_MMCSD_OPMODE_POLLED, &amp;status);
	        //Configure MMCSD module
	        ....
	        ....
	        //Read the CID information form card and store it in MMCSD handle
	        status = SD_sendAllCID(mmcsdHandle, &amp;sdCardIdObj);

	        //Read the CID data from the internal handle
	     	ataErr = MMC_read_CID(ataState-&gt;pAtaMediaState, csdBuf);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gad815e54ad246ae449a41e7b4c7e7665b"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_read_CSD" ref="gad815e54ad246ae449a41e7b4c7e7665b" args="(void *pAtaMediaState, unsigned int *pBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_read_CSD </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_read_CSD</b> </p>
<p><b>Description</b> <br/>
 This function is used to read the MMCSD card specific information. CSD information stored in the internal MMCSD handle is copied to the given data buffer. This function stores 8 words each of length 16bit into the given buffer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
            pBuf              Pointer to data buffer to store CSD information
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_Open and MMC_getCardCsd/SD_getCardCsd APIs should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Writes CSD data to given buffer</p>
<p><b>Modifies</b> <br/>
 Data in pBuf</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MMCControllerObj    pMmcsdContObj;
            CSL_MmcsdHandle 		mmcsdHandle;
            CSL_MMCCardCsdObj 		sdCardCsdObj;
			AtaMMCState             ataMediaState;
			AtaState                ataState;
			AtaError                ataErr;
			unsigned int            csdBuf[8];
			CSL_Status              status;

            ataState-&gt;pAtaMediaState = &amp;ataMediaState;

            //Open MMCSD module
	        mmcsdHandle = MMC_open(&amp;pMmcsdContObj, CSL_MMCSD0_INST,
	                               CSL_MMCSD_OPMODE_POLLED, &amp;status);
	        //Configure MMCSD module
	        ....
	        ....
	        //Read the CSD information form card and store it in MMCSD handle
	        status = SD_getCardCsd(mmcsdHandle, &amp;sdCardCsdObj);

	        //Read the CSD data from the internal handle
	     	ataErr = MMC_read_CSD(ataState-&gt;pAtaMediaState, csdBuf);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga42474102f50665ea6e3e0b909e0b6957"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_readNextNWords" ref="ga42474102f50665ea6e3e0b909e0b6957" args="(void *pAtaMediaState, AtaUint16 *pData, AtaUint16 words)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_readNextNWords </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_readNextNWords</b> </p>
<p><b>Description</b> <br/>
 This function is used to read N words next to the previously read word from the media. This function calls MMC_readNextWord API N number of times to read the data words. High level APIs should be aware of this and use MMC_readNextWord and MMC_readNextNWords APIs with care.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
            pData             Pointer to store the data words
            word              Number of words to read
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Reads data from media</p>
<p><b>Modifies</b> <br/>
 Global Read buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			#define CSL_MMCSD_BUF_SIZE (16u)

			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaUint16      dataBuf[CSL_MMCSD_BUF_SIZE];
			AtaUint16      words;

			pAtaState = &amp;ataState;

			words  = CSL_MMCSD_BUF_SIZE;
			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaReadNextNWords(ataState-&gt;pAtaMediaState,
                                                  dataBuf, words);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gac33a4b6e29921e909ba63fbf23aaca6e"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_readNextWord" ref="gac33a4b6e29921e909ba63fbf23aaca6e" args="(void *pAtaMediaState, AtaUint16 *pWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_readNextWord </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pWord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_readNextWord</b> </p>
<p><b>Description</b> <br/>
 This function is used to read a word next to the previously read word from the media. This function reads the words from the buffered data and send to the application. After reading 256 words from the global read buffer, this functions reads 256 words from the media and stores in the global read buffer. MMC_issueReadCommand functions should be called before calling this function for first time.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
            pWord             Pointer to store the data word
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully. <br/>
 MMC_issueReadCommand should be called when calling MMC_readNextWord function for first time</p>
<p><b> Post Condition </b> <br/>
 Copies a data word into pWord</p>
<p><b>Modifies</b> <br/>
 Data in pWord</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaUint16      data;
			AtaSector      phySector;
			AtaUint16      sectCnt;

			pAtaState = &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaIssueReadCommand(phySector,
                                                    ataState-&gt;pAtaMediaState,
                                                    sectCnt);

            ataErr = pAtaState-&gt;AtaReadNextWord(ataState-&gt;pAtaMediaState,
                                                &amp;data);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga8ccf47efae5b6671edfb4e50715e128b"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_readNextWord1" ref="ga8ccf47efae5b6671edfb4e50715e128b" args="(void *pAtaMediaState, AtaUint16 *pWord, AtaUint16 word_delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_readNextWord1 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>word_delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_readNextWord1</b> </p>
<p><b>Description</b> <br/>
 This function is used to read a word next to the previously read word from the media. This function reads the words from the buffered data and send to the application. After readinmg 256 words from the global read buffer, this functions reads 256 words from the media and stores in the global read buffer. MMC_issueReadCommand functions should be called before calling this function for first time.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
            pWord             Pointer to store the data word

     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully. <br/>
 MMC_issueReadCommand should be called when calling MMC_readNextWord function for first time</p>
<p><b> Post Condition </b> <br/>
 Copies a data word into pWord</p>
<p><b>Modifies</b> <br/>
 Data in pWord</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaUint16      data;
			AtaSector      phySector;
			AtaUint16      sectCnt;

			pAtaState = &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaIssueReadCommand(phySector,
                                                    ataState-&gt;pAtaMediaState,
                                                    sectCnt);

            ataErr = pAtaState-&gt;AtaReadNextWord(ataState-&gt;pAtaMediaState,
                                                &amp;data);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga52ba79b3047d32681fd2f3e507df2792"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_readNSectors" ref="ga52ba79b3047d32681fd2f3e507df2792" args="(void *pAtaMediaState, AtaUint16 *pReadBuf, AtaSector startSector, AtaUint16 sectorCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_readNSectors </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pReadBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaSector&#160;</td>
          <td class="paramname"><em>startSector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>sectorCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_readNSectors</b> </p>
<p><b>Description</b> <br/>
 This function is used to read N sectors from MMC/SD card. Data buffer should be large enough to hold the data read from multiple sectors. Each sector size will be 512 bytes</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
            pReadBuf          Pointer to store read data
            startSector       Starting sector number to read
            sectorCount       Number of sectors to read
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Reads data from media</p>
<p><b>Modifies</b> <br/>
 Read buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			#define CSL_MMCSD_BUF_SIZE (256u)

			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaError       ataErr;
			AtaUint16      dataBuf[CSL_MMCSD_BUF_SIZE];
			AtaUint16      words;
			Uint16         sectNum;

            ataState-&gt;pAtaMediaState = &amp;ataMediaState;
			words   = CSL_MMCSD_BUF_SIZE;
			sectNum = 0;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = MMC_readNSectors(ataState-&gt;pAtaMediaStatee, dataBuf,
                                      words, sectNum, 8);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gafd44c2a140fd9eb1c97e623515b256aa"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_reset" ref="gafd44c2a140fd9eb1c97e623515b256aa" args="(void *pAtaMediaState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_reset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_reset</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;

			pAtaState = &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaReset(ataState-&gt;pAtaMediaState);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga05378697af9598064568483c00c30f9c"></a><!-- doxytag: member="csl_mmcsd.h::MMC_saveStatus" ref="ga05378697af9598064568483c00c30f9c" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_saveStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_saveStatus</b> </p>
<p><b>Description</b> <br/>
 This function stores the value of MMCST0 and MMCST1 registers in the card object strutcure present in the MMCSD handle.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd    Handle to the MMCSD
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 Saves the value of MMCST0 and MMCST1</p>
<p><b>Modifies</b> <br/>
 Card object structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            Uint16                maskValue;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_saveStatus(hMmcsd);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga2b7407c0ddc8d6740109c528e0848d05"></a><!-- doxytag: member="csl_mmcsd.h::MMC_selectCard" ref="ga2b7407c0ddc8d6740109c528e0848d05" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardObj *pMmcCardObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_selectCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_selectCard</b> </p>
<p><b>Description</b> <br/>
 This function detects which card (MMC/SD/SDHC) is inserted. Information of the card detected will be populated to the card object structure passed as parameter.</p>
<p>MMC object structure passed to this function should global structure variable which persists till end of the program since it is stored by MMCSD CSL for reference in other APIs.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD.
            pMmcCardObj       Pointer to the MMCSD Card Info.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle       hMmcsd;
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MMCCardObj        mmcCardObj;
            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga4b1a903e9a756253ff1cc15130f08eb3"></a><!-- doxytag: member="csl_mmcsd.h::MMC_sendAllCID" ref="ga4b1a903e9a756253ff1cc15130f08eb3" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardIdObj *pMmcCardIdObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_sendAllCID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardIdObj.html">CSL_MMCCardIdObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardIdObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_sendAllCID</b> </p>
<p><b>Description</b> <br/>
 This will fetch the Information about MMC Card Id and update into the passed id structure.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd           Handle to the MMCSD.
            pMmcCardIdObj    Pointer to the MMC Card ID Info.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1.MMC_open() API should be called successfully. <br/>
 2.MMC_selectCard() API should be called before this so that it will do some needful work for particular card detected. <br/>
 3.If Card detected is MMC then <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a> for specific to MMC.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 pMmcCardIdObj will be populated.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MMCCardObj          mmcCardObj;
            CSL_MMCCardIdObj        mmcCardIdObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint16                  clkDivValue;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

            clkDivValue = 0x4 //As MMC clock max is 20MHz and
                                Function clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);

            status = MMC_sendAllCID(hMmcsd, &amp;mmcCardIdObj);
            For example following value will be populated.
            pMmcCardIdObj-&gt;mfgId         = ;
            pMmcCardIdObj-&gt;serialNumber  = ;
            pMmcCardIdObj-&gt;monthCode     = ;
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga66fa12d1e3126f4b5fbee1327381f87c"></a><!-- doxytag: member="csl_mmcsd.h::MMC_sendCmd" ref="ga66fa12d1e3126f4b5fbee1327381f87c" args="(CSL_MmcsdHandle hMmcsd, Uint32 cmd, Uint32 arg, Uint16 eventFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int16 MMC_sendCmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>eventFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_sendCmd</b> </p>
<p><b>Description</b> <br/>
 This is used to send a command to the memory card. Lower 16 bits of the parameter 'cmd' should contain the command that needs to be written to MMCCMD1 register. Upper 16 bits of the 'cmd' should contain the data that needs to be written to MMCCMD2 register.</p>
<p>NOTE:SETTING THE MMCCMD2 VALUE TO '1' IS ALLOWED ONLY TO DATA WRITE COMMANDS THAT USES DMA FOR DATA TRANSFER. FOR OTHER COMMANDS UPPER 16 BITS OF 'CMD' SHOULD ALWAYS BE ZERO.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd        Handle to the MMCSD.
            cmd           Command index.
            arg           Argument.
            eventFlags    MMCSD Event Flags to wait for.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle       hMmcsd;
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            Uint32                cmd;
            Uint32                arg;
            Uint16                eventFlags;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            cmd        = CSL_MMCSD_WRITE_INIT_CMD;
            arg        = CSL_MMCSD_ARG_RESET;
            eventFlags = CSL_MMCSD_EVENT_EOFCMD;

            status = MMC_sendCmd(hMmcsd, cmd, arg, eventFlags);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga7819c9f81a2db4e17d5001e6bab9774f"></a><!-- doxytag: member="csl_mmcsd.h::MMC_sendGoIdle" ref="ga7819c9f81a2db4e17d5001e6bab9774f" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_sendGoIdle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_sendGoIdle</b> </p>
<p><b>Description</b> <br/>
 This function broadcasts Go Idle command for Setting all cards to the idle state.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd    Handle to the MMCSD
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 This should be called just after <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_sendGoIdle(hMmcsd);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga930824e2cdbfd96d66730756219e912f"></a><!-- doxytag: member="csl_mmcsd.h::MMC_sendOpCond" ref="ga930824e2cdbfd96d66730756219e912f" args="(CSL_MmcsdHandle hMmcsd, Uint16 clkDivValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_sendOpCond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>clkDivValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_sendOpCond</b> </p>
<p><b>Description</b> <br/>
 This function will set the clock to the SD or MMC Card according to passed parameter of Card Type.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD
            clkDivValue       Clock Div value for MMC or SD card.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MMCCardObj          mmcCardObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint16                  clkDivValue;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

            pMmmcCardObj-&gt;cardType = CSL_MMC_CARD;

            clkDivValue = 0x4 //as MMC clock max is 20MHz and Function clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gae274ce72051283a596749b055ea5cd2d"></a><!-- doxytag: member="csl_mmcsd.h::MMC_sendSwitchCmd" ref="gae274ce72051283a596749b055ea5cd2d" args="(CSL_MmcsdHandle hMmcsd, Uint32 argument)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_sendSwitchCmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends switch commmand to eMMC card. </p>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">argument</td><td>[IN] Switch command argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="ga092ceb666b92ba2d19946c827a6b35de"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setBlockLength" ref="ga092ceb666b92ba2d19946c827a6b35de" args="(CSL_MmcsdHandle hMmcsd, Uint32 blockLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setBlockLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>blockLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setBlockLength</b> </p>
<p><b>Description</b> <br/>
 This function is used to set block length of the memory card using command 16. In the case of a Standard Capacity SD Memory Card or MMC card, command 16 sets the block length(in bytes) for all following block commands (read, write, lock). Default block length is fixed to 512 bytes. In the case of a High Capacity SD memory card, block length set by CMD16 command does not affect the memory read and write commands. Always 512 bytes fixed block length is used.</p>
<p>This API does not verify the value of block length passed as parameter. Calling functions should make sure that the block length passed is proper with respect to the card under operation.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd      MMCSD handle
            blockLen    Length of the memory card block
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Sets MMC/SD block length</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);

            status = MMC_setBlockLength(hMmcsd, CSL_MMCSD_BLOCK_LENGTH);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga1658e5a530ffce50f24ebd0c2a70cb60"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setBootBusWidth" ref="ga1658e5a530ffce50f24ebd0c2a70cb60" args="(CSL_MmcsdHandle hMmcsd, CSL_MmcsdBootBusWidth bootBusWidth, Bool resetBusWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setBootBusWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__ENUM.html#ga6dd64c9f21aa32b820c9b626c1792191">CSL_MmcsdBootBusWidth</a>&#160;</td>
          <td class="paramname"><em>bootBusWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>resetBusWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the boot bus width. </p>
<p>This API is used to configure the boot bus width for eMMC card</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">bootBusWidth</td><td>[IN] Boot Bus width 0 - 1bit mode 1 - 4bit mode </td></tr>
    <tr><td class="paramname">resetBusWidth</td><td>[IN] 0 - Reset bus width to 1 after boot operation 1 - Retain boot bus width after boot operation</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: C5505/C5515 MMCSD controller does not support 8-bit mode</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gae1470b3d6a92e29588d52deb2b9673f5"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setCallBack" ref="gae1470b3d6a92e29588d52deb2b9673f5" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCallBackObj *pFunction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCallBackObj.html">CSL_MMCCallBackObj</a> *&#160;</td>
          <td class="paramname"><em>pFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setCallBack</b> </p>
<p><b>Description</b> <br/>
 This function sets the address of call back routines which will be called from MMCSD ISR.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd       Handle to the MMCSD.
            pFunction    Pointer to the isr function.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            #define MMCSD_ISR_FUNCTION_MAX (4u)
            void mmcsd0_tx_isr(void);
            void mmcsd0_rcv_isr(void);
            void mmcsd1_tx_isr(void);
            void mmcsd1_rcv_isr(void);

            CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            CSL_MMCCallBackObj    callBckFun;

            instId = CSL_MMCSD0_INST;
            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

			callBckFun.isr[CSL_MMCSD_ISR_TXMT] = mmcsd_tx_isr;
			callBckFun.isr[CSL_MMCSD_ISR_RCV]  = mmcsd_rcv_isr;

            status = MMC_setCallBack(hMmcsd, &amp;callBckFun);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga96a951e3a784d66d98977177b0924959"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setCardPtr" ref="ga96a951e3a784d66d98977177b0924959" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardObj *pMmcCardObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setCardPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setCardPtr</b> </p>
<p><b>Description</b> <br/>
 This function will set the card object information address into the MMCSD handle. Implementation is limited only to the software layer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD.
            CSL_MMCCardObj    Pointer to the MMCSD Card Object.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully before this.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 Card object structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MMCCardObj        mmcCardObj;
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_setCardPtr(hMmcsd, &amp;mmcCardObj);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga78aad8f81a6cb388dff08240e39fc018"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setCardType" ref="ga78aad8f81a6cb388dff08240e39fc018" args="(CSL_MMCCardObj *pCardObj, CSL_CardType cardType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setCardType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pCardObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__ENUM.html#ga90fae15acd7c0ccde7119b9e47ec7a76">CSL_CardType</a>&#160;</td>
          <td class="paramname"><em>cardType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setCardType</b> </p>
<p><b>Description</b> <br/>
 This API just updates the software structure and does not update any hardware registers</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pCardObj    Pointer to the card object.
            cardType    type of card MMC or SD.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

            CSL_MMCCardObj        cardObj;
            CSL_CardType          cardType;

            cardType = CSL_SD_CARD;

            status = MMC_setCardType(&amp;cardObj, cardType);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaf3d12f302957fef49d39a7ec849ca0da"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setDataTransferCallback" ref="gaf3d12f302957fef49d39a7ec849ca0da" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCDataTxferCallBackPtr dataTransferCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setDataTransferCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__DATASTRUCT.html#ga996256ad667c6afe44badfd5b535ade2">CSL_MMCDataTxferCallBackPtr</a>&#160;</td>
          <td class="paramname"><em>dataTransferCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setDataTransferCallback</b> </p>
<p><b>Description</b> <br/>
 This function stores the data transfer call back function pointer in the MMCSD handle. This callback pointer is used by the MMCSD write and read APIs to issue callback during data transfer operations. This is to facilitate application/driver programs handle MMCSD interrupt in their own way depending on their requirements. Callback function is used when MMCSD is operating in DMA or interrupt mode. During DMA mode operation, call back function will be called after starting the DMA data transfer. During interrupt mode operation call back function will be called 1. For checking read/write command response 2. For checking transit/receive ready bit 3. For checking data done bit</p>
<p>In both the operating modes callback function should wait for the MMCSD interrupt. Upon receiving the interrupt, all the MMCSD events should be disabled. MMCSD handle will be passed to the callback function as a parameter.</p>
<p>Setting the callback function is optional for DMA mode but is mandatory for interrupt mode operation. MMC_read/MMC_write APIs return with error in case of no callback is set and MMCSD is configured for interrupt mode.</p>
<p>NOTE: Same callback pointer will be used by write and read APIs. Callback function is applicable to DMA and interrupt mode only. Should not call this API when MMCSD is operation in polled mode.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd                  MMCSD handle
            dataTransferCallback    Transfer done callback pointer
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Stores the transfer done callback pointer in MMC handle</p>
<p><b>Modifies</b> <br/>
 MMC handle</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle                hMmcsd;
            CSL_MMCDataTxferCallBackPtr    dataTransferCallback;
            CSL_MmcsdInstId                instId;
            CSL_status                     status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);

            status = MMC_setDataTransferCallback(hMmcsd, dataTransferCallback);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga352c10b5cb98c67b2edcaca9a527d496"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setDmaChanConfig" ref="ga352c10b5cb98c67b2edcaca9a527d496" args="(CSL_MmcsdHandle hMmcsd, CSL_MmcsdDmaConfig dmaConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setDmaChanConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MmcsdDmaConfig.html">CSL_MmcsdDmaConfig</a>&#160;</td>
          <td class="paramname"><em>dmaConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setDmaChanConfig</b> </p>
<p><b>Description</b> <br/>
 This function is used to set the DMA channel configurations. DMA channel configuration values sent by the application are stored in the MMCSD handle and used by the MMC write and read functions. DMA read and write channel configurations can be set independently with only one channel at a time using this function. Direction of the DMA channel is identified using the member 'chanDir' of CSL_MMCDmaConfig structure. Operating mode of the MMCSD module needs to be set to DMA mode for using this API.</p>
<p>Members of CSL_MMCDmaConfig structure are subset of <a class="el" href="structCSL__DMA__Config.html" title="DMA configuration structure.">CSL_DMA_Config</a> structure. Other configuration values DMA source address, destination address, DMA data length etc are not configurable by MMCSD application program and are set by the MMCSD read/write API depending on the request from file system.</p>
<p>Only 4word and 8word DMA burst length is allowed for MMCSD (burstLen). Any other burst length will be ignored and DMA will be configured to 8word burst length by default.</p>
<p>This API is an optional one. Default DMA configurations are assigned by the MMC_open function. No need to call this API until and unless a different DMA configurations are required by the application.</p>
<p>NOTE:This API should not be called when MMCSD is operating Polled mode.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd       MMCSD handle
            dmaConfig    DMA configuration structure
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid configuration parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Stores the DMA configuration values in MMC handle</p>
<p><b>Modifies</b> <br/>
 MMC handle</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj    pMmcsdContObj;
            CSL_MmcsdHandle         hMmcsd;;
            CSL_MmcsdDmaConfig      dmaWriteCfg;
            CSL_MmcsdDmaConfig      dmaReadCfg;
            CSL_MmcsdInstId         instId;
            CSL_status              status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);

			dmaWriteCfg.autoMode     = CSL_DMA_AUTORELOAD_DISABLE;
			dmaWriteCfg.burstLen     = CSL_DMA_TXBURST_8WORD;
			dmaWriteCfg.chanDir      = CSL_DMA_WRITE;
			dmaWriteCfg.dmaInt       = CSL_DMA_INTERRUPT_ENABLE;

			// Set the DMA write channel configuration
            status = MMC_setDmaChanConfig(hMmcsd, dmaWriteCfg);

			dmaReadCfg.autoMode     = CSL_DMA_AUTORELOAD_DISABLE;
			dmaReadCfg.burstLen     = CSL_DMA_TXBURST_8WORD;
			dmaReadCfg.chanDir      = CSL_DMA_READ;
			dmaReadCfg.dmaInt       = CSL_DMA_INTERRUPT_ENABLE;

			// Set the DMA read channel configuration
            status = MMC_setDmaChanConfig(hMmcsd, dmaReadCfg);

    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga9cabd2c2de7225dd78daa2387bf8aed4"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setDmaHandle" ref="ga9cabd2c2de7225dd78daa2387bf8aed4" args="(CSL_MmcsdHandle hMmcsd, CSL_DMA_Handle hDmaWrite, CSL_DMA_Handle hDmaRead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setDmaHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__DMA__ChannelObj.html">CSL_DMA_Handle</a>&#160;</td>
          <td class="paramname"><em>hDmaWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__DMA__ChannelObj.html">CSL_DMA_Handle</a>&#160;</td>
          <td class="paramname"><em>hDmaRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setDmaHandle</b> </p>
<p><b>Description</b> <br/>
 This function stores the DMA handles sent by the application program. DMA handle stored in MMCSD handle will be used by the MMC read/write APIs to transfer the data in DMA mode. This API requires that MMCSD operating mode should be set to DMA using MMC_open function. DMA channel handles should be sent by the application in proper order. DMA channel needs to opened before calling this API. This channels will be closed by the MMC_close API.</p>
<p>NOTE:This API should not be called when MMCSD is operating Polled mode.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd       MMCSD handle
            hDmaWrite    Handle to DMA channel used for MMCSD write operation
            hDmaRead     Handle to DMA channel used for MMCSD read operation
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid DMA handle</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> and <a class="el" href="group__CSL__DMA__FUNCTION.html#ga3c9ecb2992e2ffa1cabf0512cdc88d31">DMA_open()</a> functions should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Stores the DMA handle in MMC handle</p>
<p><b>Modifies</b> <br/>
 MMC handle</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_MMCControllerObj  pMmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_DMA_Handle        dmaWrHandle;
            CSL_DMA_Handle        dmaRdHandle;
            CSL_DMA_ChannelObj    dmaWrChanObj;
            CSL_DMA_ChannelObj    dmaRdChanObj;

            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);

            dmaWrHandle = DMA_open(&amp;dmaWrChanObj, CSL_DMA_CHAN0);

            dmaRdHandle = DMA_open(&amp;dmaRdChanObj, CSL_DMA_CHAN1);

            // Set DMA handle
            status = MMC_setDmaHandle(hMmcsd, dmaWrHandle, dmaRdHandle);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gada1f8f1c1fa95145770944ec6bb58307"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setEMMCBusWidth" ref="gada1f8f1c1fa95145770944ec6bb58307" args="(CSL_MmcsdHandle hMmcsd, Bool busWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setEMMCBusWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>busWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the bus width. </p>
<p>This API is used to configure the bus width for MMC/SD card</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">busWidth</td><td>[IN] Bus width 0 - 1bit mode 1 - 4bit mode</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: C5505/C5515 MMCSD controller does not support 8-bit mode</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="ga3be5dcff1884f09477361fe4fd9f57e8"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setEndianMode" ref="ga3be5dcff1884f09477361fe4fd9f57e8" args="(CSL_MmcsdHandle hMmcsd, CSL_MmcsdEndianMode writeEndianMode, CSL_MmcsdEndianMode readEndianMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setEndianMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__ENUM.html#gad374520910fa2c1324dc36d2ae22fa7d">CSL_MmcsdEndianMode</a>&#160;</td>
          <td class="paramname"><em>writeEndianMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__MMCSD__ENUM.html#gad374520910fa2c1324dc36d2ae22fa7d">CSL_MmcsdEndianMode</a>&#160;</td>
          <td class="paramname"><em>readEndianMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setEndianMode</b> </p>
<p><b>Description</b> <br/>
 This function is used to set endian mode of the MMC/SD controller. Endian mode set using this API decides the way in which data is transferred from FIFO to storage device.</p>
<p>Default endianness of MMCSD controller: Chip C5504 and C5505: LITTLE ENDIAN. Chip C5514 and C5515: BIG ENDIAN.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd             MMCSD handle
            writeEndianMode    Endian mode for MMC/SD write operation
            readEndianMode     Endian mode for MMC/SD read operation
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Sets MMC/SD endian mode for write and operations</p>
<p><b>Modifies</b> <br/>
 MMC/SD control register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			CSL_MMCControllerObj  pMmcsdContObj;
            CSL_MmcsdHandle       hMmcsd;
            CSL_MmcsdInstId       instId;
            CSL_status            status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);

            status = MMC_setEndianMode(hMmcsd, CSL_MMCSD_ENDIAN_LITTLE,
                                      CSL_MMCSD_ENDIAN_LITTLE);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga126887ca3952a6130e4957846c26ac68"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setRca" ref="ga126887ca3952a6130e4957846c26ac68" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardObj *pMmcCardObj, Uint16 rCardAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setRca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>rCardAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setRca</b> </p>
<p><b>Description</b> <br/>
 This function sets the relative card address for MMC Card. Relative card address is stored in <a class="el" href="structCSL__MMCCardObj.html" title="structure for card specific information.">CSL_MMCCardObj</a> which can used by other MMCSD CSL APIs.</p>
<p>Application programs should use only this function to set the RCA of MMC card. RCA passed to this function will be stored in the MMCSD handle and is used by other MMCSD CSL APIs.</p>
<p>NOTE: THIS FUNCTION IS SPECIFIC TO MMC CARD AND SHOULD NOT BE USED WITH THE SD CARD. FOR MMC CARD CMD3(SET_RELATIVE_ADDR) IS USED TO SET THE CARD ADDRESS AND FOR SD CARD CMD3(SEND_RELATIVE_ADDR) IS USED TO REQUEST THE CARD ADDRESS.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD.
            pMmcCardObj       Pointer to the MMC Card Info.
            rCardAddr         Relative card address.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br/>
 3: If Card detected is MMC then <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a> for specific to MMC.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MMCCardObj          mmcCardObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint16                  clkDivValue;
            Uint16                  rCardAddr;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

            clkDivValue = 0x4 //as MMC clock max is 20MHz and Function clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);
            rCardAddr = 0x100;

            status = MMC_setRca(hMmcsd, &amp;mmcCardObj, rCardAddr);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga64755486e84519aceab8f6611c76bce8"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setupNative" ref="ga64755486e84519aceab8f6611c76bce8" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCSetupNative *pMmcInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setupNative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCSetupNative.html">CSL_MMCSetupNative</a> *&#160;</td>
          <td class="paramname"><em>pMmcInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setupNative</b> </p>
<p><b>Description</b> <br/>
 This function will set initial configuration to all the MMCSD registers.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd      Handle to the MMCSD.
            pMmcInit    Pointer to CSL_MMCSetupNative state variable.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br/>
 MMCSD Registers will be populated.</p>
<p><b>Modifies</b> <br/>
 MMCSD Registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle       hMmcsd;
			CSL_MMCControllerObj  pMmcsdContObj;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            CSL_MMCConfig         mmcInit;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            Note: CSL_MMCConfig field are following.
            mmcInit.dmaEnable         = CSL_MMCSD_MMCCMD2_DMATRIG_NO;
            mmcInit.dat3EdgeDetection = CSL_MMCSD_MMCCTL_DATEG_DISABLE;
            mmcInit.cdiv              = CSL_MMCSD_CLK_DIV_INIT;
            mmcInit.rspTimeout        = CSL_MMCSD_RESPONSE_TIMEOUT;
            mmcInit.dataTimeout       = CSL_MMCSD_DATA_RW_TIMEOUT;
            mmcInit.blockLen          = CSL_MMCSD_MIN_BLOCK_LENGTH;

            status = MMC_setupNative(hMmcsd, &amp;mmcInit);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga8911fdaf15d677af8c31463963c222a4"></a><!-- doxytag: member="csl_mmcsd.h::MMC_setWriteBlkEraseCnt" ref="ga8911fdaf15d677af8c31463963c222a4" args="(CSL_MmcsdHandle hMmcsd, Uint32 blkCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setWriteBlkEraseCnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>blkCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_setWriteBlkEraseCnt</b> </p>
<p><b>Description</b> <br/>
 Function to set the number of write blocks to be preerased before writing. Set write block erase count command need to be used for faster multiple block write command. Calling this function is not mandatory. In case of calling this API for better performance, it should be called just before calling MMC_write function.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd      MMCSD handle
            blkCnt      Number of blocks
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Sets preerase block count</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MmcsdHandle         hMmcsd;
            CSL_MmcsdInstId         instId;
            CSL_status              status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);

            status = MMC_setWriteBlkEraseCnt(hMmcsd, 16);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gab31b48d48ffc562e53f94c81c1ad6613"></a><!-- doxytag: member="csl_mmcsd.h::MMC_stop" ref="gab31b48d48ffc562e53f94c81c1ad6613" args="(CSL_MmcsdHandle hMmcsd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_stop</b> </p>
<p><b>Description</b> <br/>
 Function to stop the MMC/SD transfer and receive events. This function sends CMD12 to the memory card.</p>
<p>NOTE: STOP command should be sent to the card when it is in 'data'(read) or 'rcv'(write) state. Sending STOP command while the card in any other state will result in command timeout.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this. <br/>
 Card should be addressed.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_stop(hMmcsd);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga7f52bd655086f5a0d406d431c020f0a4"></a><!-- doxytag: member="csl_mmcsd.h::MMC_write" ref="ga7f52bd655086f5a0d406d431c020f0a4" args="(CSL_MmcsdHandle hMmcsd, Uint32 cardAddr, Uint16 noOfBytes, Uint16 *pWriteBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cardAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>noOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pWriteBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_write</b> </p>
<p><b>Description</b> <br/>
 This function writes data in the write data buffer to the memory card at a given address.</p>
<p>'cardAddr' represents the address location in the card to be accessed. For the standard capacity cards this parameter will be a value in multiples of 512. That means to write a sector number 1 cardAddr will be 1*512, to write a sector number 2 cardAddr will be 2*512 and so on. For the high capacity cards 'cardAddr' parameter will be same as the sector number. That means to write a sector number 1 cardAddr will be 1, to write a sector number 2 cardAddr will be 2 and so on. Reason for this is high capacity cards uses BLOCK addressing instead of the BYTE addressing used by the standard capacity cards to increase the addressable memory capacity.</p>
<p>Detection of high capacity cards can be verified using the flag 'sdHcDetected' in the MMCSD card object structure. sdHcDetected = TRUE - SD card is high capacity card sdHcDetected = FALSE - SD card is standard capacity card</p>
<p>NOTE: CARE SHOULD BE TAKEN WHILE PASSING THE 'cardAddr' PARAMETER. USING BYTE ADDRESSING WITH HIGH CAPACITY CARDS WILL LEAD TO OUT OF SECTOR BOUNDARY ACCESS AND RESULTS IN CODE HANGING FOR MMCSD RESPONSE.</p>
<p>NOTE: Endian mode of the data transfer depends on the parameter 'writeEndianMode' in the MMC handle. Default value for the endian mode is 'LITTLE ENDIAN' which will be set during MMC open. Endian mode can be configured using <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3be5dcff1884f09477361fe4fd9f57e8">MMC_setEndianMode()</a>. DO NOT CHANGE THE ENDIAN MODE WITH OUT USING THIS API.</p>
<p>NOTE: When transferring data in DMA mode, word swap will be done for the data buffer when MMCSD is configured for little endian mode. No word swap is required in upper SW layers.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD
            cardAddr          location to read from.
            noOfBytes         no of bytes to read.
            pWriteBuffer      pointer to a buffer.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - card Response time out</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1.MMC_open() API should be called successfully. <br/>
 2.MMC_selectCard() API should be called before this so that it will do some needful work for particular card detected. <br/>
 3. <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to card . <br/>
 4. If Card detected is SD then call <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga3a7183e22e839d1f57f6d143ce78c3a4">SD_getCardCsd()</a> specific to SD. If Card detected is SD then call <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga0ab342afd3a8406390cab83fbcd2a720">MMC_getCardCsd()</a> specific to MMC</p>
<p><b> Post Condition </b> <br/>
 Writes the data to card</p>
<p><b>Modifies</b> <br/>
 MMC/SD card will populated with the passed buffer values.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle       hMmcsd;
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MMCCardObj        sdCardObj;
            CSL_MMCCardCsdObj     sdCardCsdObj;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            Uint16                clkDivValue;
            Uint16                noOfBytes;
            Uint16                cardAddr;
            Uint16                writeBuffer[256];

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

            sdCardObj.cardType = CSL_SD_CARD;
             clkDivValue = 0x1 //as SD clock max is 50MHz and Function
                                 clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);

            status = SD_getCardCsd(hMmcsd, &amp;sdCardCsdObj);
            For example following value will be populated.
            pSdCardCsdObj-&gt;readBlLen         = ;
            pSdCardCsdObj-&gt;cSize  = ;
            These value will be useful to fetch the card specific information
            These figure are tested with 1GB Ultra SD Card
            blockLength  = 512 Bytes
            cardCapacity = 0x1015808000 Bytes
            totalSectors = 0x1984000 sector

            cardAddr = 0x200;
            noOfBytes = 512;

            status = MMC_write(hMmcsd, cardAddr, noOfBytes, &amp;writeBuffer);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga1ce2cec113d65fdb5a88bdd6f462e330"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_writeNSectors" ref="ga1ce2cec113d65fdb5a88bdd6f462e330" args="(void *pAtaMediaState, AtaUint16 *pWriteBuf, AtaSector startSector, AtaUint16 sectorCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_writeNSectors </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pWriteBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaSector&#160;</td>
          <td class="paramname"><em>startSector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>sectorCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_writeNSectors</b> </p>
<p><b>Description</b> <br/>
 This function is used to write N number of sectors to MMC/SD card. Each sector size will be 512 bytes</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
            pWriteBuf         Pointer to write data buffer
            startSector       Starting sector number to write
            sectorCount       Number of sectors to write
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Writes data to media</p>
<p><b>Modifies</b> <br/>
 Data in the MMC/SD card</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			#define CSL_MMCSD_BUF_SIZE (256u)

			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaError       ataErr;
			AtaUint16      dataBuf[CSL_MMCSD_BUF_SIZE];
			AtaUint16      words;
			Uint16         sectNum;

            ataState-&gt;pAtaMediaState = &amp;ataMediaState;
			words   = CSL_MMCSD_BUF_SIZE;
			sectNum = 0;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = MMC_writeNSectors(ataState-&gt;pAtaMediaState, dataBuf,
                                       words, sectNum, 8);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gad904a36b62dff38809b18706f2b217a8"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_writeSector" ref="gad904a36b62dff38809b18706f2b217a8" args="(AtaSector phySector, void *pAtaMediaState, AtaUint16 *pWord, int byteSwap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_writeSector </td>
          <td>(</td>
          <td class="paramtype">AtaSector&#160;</td>
          <td class="paramname"><em>phySector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteSwap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_writeSector</b> </p>
<p><b>Description</b> <br/>
 This function is used to write data to the media. This function can write 512 bytes of data at one time.</p>
<p>Programs calling this function should assign proper value to ATA_No_Swap in case of using that varaible.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            phySector         Sector number from which data needs to be read
            pAtaMediaState    ATA media state structure
            pWord             Write data buffer
            byteSwap          Flag to request for the byte swap
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Writes Data to MMC/SD card</p>
<p><b>Modifies</b> <br/>
 MMCSD Sector data</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			#define CSL_MMCSD_BUF_SIZE (256u)

			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;
			AtaSector      phySector;
			AtaUint16      writeBuf[CSL_MMCSD_BUF_SIZE];

			pAtaState = &amp;ataState;

			phySector = 0;
			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaWriteSector(phySector,
                                               ataState-&gt;pAtaMediaState,
                                               writeBuf, FALSE);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga387ce86f026b4c9a65f057bd0d4bf0dc"></a><!-- doxytag: member="csl_mmcsd_ataIf.h::MMC_writeSectorFlush" ref="ga387ce86f026b4c9a65f057bd0d4bf0dc" args="(void *pAtaMediaState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_writeSectorFlush </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>MMC_writeSectorFlush</b> </p>
<p><b>Description</b> <br/>
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            pAtaMediaState    ATA media state structure
     </pre></div><p><b> Return Value </b> AtaError </p>
<ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br/>
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			AtaMMCState    ataMediaState;
			AtaState       ataState;
			AtaState       *pAtaState;
			AtaError       ataErr;

			pAtaState = &amp;ataState;

			ataState-&gt;pAtaMediaState = &amp;ataMediaState;

			ataErr = MMC_initState(&amp;ataState);

            ataErr = pAtaState-&gt;AtaWriteSectorFlush(ataState-&gt;pAtaMediaState);

     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gadff5ef92220929877229fddea116db6d"></a><!-- doxytag: member="csl_mmcsd.h::SD_configurePullup" ref="gadff5ef92220929877229fddea116db6d" args="(CSL_MmcsdHandle hMmcsd, Bool pullupCfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_configurePullup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>pullupCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SD_configurePullup</b> </p>
<p><b>Description</b> <br/>
 Function to Connenct/Disconnect the SD card internal pull-up resistors. This function is specific to SD card; cannot be used with MMC card</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd         MMCSD handle
            pullupCfg      Flag indicate the pull-up configuration
                             0 - Disconnects the pull-up resistor
                             1 - Connects the pull-up resistor
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully <br/>
 Card should be selected</p>
<p><b> Post Condition </b> <br/>
 Connencts/Disconnects SD card pull-up resistor</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MmcsdHandle         hMmcsd;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint32                  cardStatus;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);
            ....

            //Select the card

            ....

            status = SD_configurePullup(hMmcsd, 0);
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga3a7183e22e839d1f57f6d143ce78c3a4"></a><!-- doxytag: member="csl_mmcsd.h::SD_getCardCsd" ref="ga3a7183e22e839d1f57f6d143ce78c3a4" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardCsdObj *pSdCardCsdObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_getCardCsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardCsdObj.html">CSL_MMCCardCsdObj</a> *&#160;</td>
          <td class="paramname"><em>pSdCardCsdObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SD_getCardCsd</b> </p>
<p><b>Description</b> <br/>
 This function will update the CSD Structure info of SD Card.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD.
            pSdCardCsdObj     Pointer to the SD Card CSD Info.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br/>
 3:If Card detected is SD then <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to SD.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle       hMmcsd;
			CSL_MMCControllerObj  mmcsdContObj;
            CSL_MMCCardObj        sdCardObj;
            CSL_MMCCardCsdObj     sdCardCsdObj;
            CSL_MmcsdInstId       instId;
            CSL_status            status;
            Uint16                clkDivValue;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

            clkDivValue = 0x1 //As SD clock max is 50MHz and Function clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);

            status = SD_getCardCsd(hMmcsd, &amp;sdCardCsdObj);
            For example following value will be populated.
            sdCardCsdObj.readBlLen         = ;
            sdCardCsdObj.cSize  = ;
            These values will be useful to fetch the card specific information
            like these-----
            These figure are tested with 1GB Ultra SD Card
            blockLength      = 512 Bytes
            cardCapacity     = 0x1015808000 Bytes
            totalSectors     = 0x1984000 sector
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gaffe121b613eb075a564f8f827d1b22fa"></a><!-- doxytag: member="csl_mmcsd.h::SD_sendAllCID" ref="gaffe121b613eb075a564f8f827d1b22fa" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardIdObj *pSdCardIdObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_sendAllCID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardIdObj.html">CSL_MMCCardIdObj</a> *&#160;</td>
          <td class="paramname"><em>pSdCardIdObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SD_sendAllCID</b> </p>
<p><b>Description</b> <br/>
 This will fetch the Information about SD Card Id and update into the passed id structure.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd           Handle to the MMCSD.
            pSdCardIdObj     Pointer to the SD Card ID Info.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br/>
 3:If Card detected is SD then <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a> specific to SD.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 pSdCardIdObj object will be populated.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MMCCardObj          sdCardObj;
            CSL_MMCCardIdObj        sdCardIdObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint16                  clkDivValue;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

            clkDivValue = 0x1 //As SD clock max is 50MHz and
                                Function clock is 100MHz
            status = MMC_sendOpCond(hMmcsd, clkDivValue);

            status = SD_sendAllCID(hMmcsd, &amp;sdCardIdObj);

            For example following value will be populated.
            sdCardIdObj.mfgId         = ;
            sdCardIdObj.serialNumber  = ;
            sdCardIdObj.monthCode     = ;
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga422c250e5c38131c42df668587162eb7"></a><!-- doxytag: member="csl_mmcsd.h::SD_sendRca" ref="ga422c250e5c38131c42df668587162eb7" args="(CSL_MmcsdHandle hMmcsd, CSL_MMCCardObj *pSdCardObj, Uint16 *pRCardAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_sendRca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MMCCardObj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pSdCardObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pRCardAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SD_sendRca</b> </p>
<p><b>Description</b> <br/>
 This function sends request for relative card address(RCA) of SD Card. RCA value published by SD card will be populated to card address parameter. RCA is also stored in <a class="el" href="structCSL__MMCCardObj.html" title="structure for card specific information.">CSL_MMCCardObj</a> to use in other MMCSD CSL APIs.</p>
<p>Application programs should use only this function to requesting the RCA from SD card. RCA published by the SD card will be stored in the MMCSD handle and is used by other MMCSD CSL APIs.</p>
<p>NOTE: THIS FUNCTION IS SPECIFIC TO SD CARD AND SHOULD NOT BE USED WITH THE MMC CARD. FOR MMC CARD CMD3(SET_RELATIVE_ADDR) IS USED TO SET THE CARD ADDRESS AND FOR SD CARD CMD3(SEND_RELATIVE_ADDR) IS USED TO REQUEST THE CARD ADDRESS.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd            Handle to the MMCSD.
            pSdCardObj        Pointer to the SD Card Info.
            pRCardAddr        Pointer to store relative card address.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 1:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br/>
 2:<a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br/>
 3:If Card detected is SD then <a class="el" href="group__CSL__MMCSD__FUNCTION.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a> for specific to SD.</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 pRCardAddr variable will be populated.</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_MmcsdHandle         hMmcsd;
			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MMCCardObj          sdCardObj;
            CSL_MmcsdInstId         instId;
            CSL_status              status;
            Uint16                  clkDivValue;
            Uint16                  rCardAddr;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                              &amp;status);

            status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

            clkDivValue = 0x1; //As SD clock max is 50MHz and Function clock is 100MHz

            status = MMC_sendOpCond(hMmcsd, clkDivValue);
            status = SD_sendRca(hMmcsd, &amp;sdCardObj, &amp;rCardAddr);
     </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="gac5311523eff70c1d40ff9e3947c57fab"></a><!-- doxytag: member="csl_mmcsd.h::SD_setBusWidth" ref="gac5311523eff70c1d40ff9e3947c57fab" args="(CSL_MmcsdHandle hMmcsd, Uint8 busWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_setBusWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>busWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>SD_setBusWidth</b> </p>
<p><b>Description</b> <br/>
 Function to set the bus with for SD card. This function sends ACMD6 to the SD card to configure the bus width. This function should be called after selecting the card using CMD7.</p>
<p>NOTE: This function is specific to SD card.Should not be used with MMC.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hMmcsd        MMCSD handle
            busWidth      bus width of the card; 0 - 1 bit, 1 - 4 bit
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br/>
 <a class="el" href="group__CSL__MMCSD__FUNCTION.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Sets SD card bus width</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			CSL_MMCControllerObj    mmcsdContObj;
            CSL_MmcsdHandle         hMmcsd;
            CSL_MmcsdInstId         instId;
            CSL_status              status;

            instId = CSL_MMCSD0_INST;

            hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                              &amp;status);

            status = SD_setBusWidth(hMmcsd, 1);
            ...
    </pre></div><p> =========================================================================== </p>

</div>
</div>
<a class="anchor" id="ga770b1ccb0e958bf9ce380bd3e8f71ed7"></a><!-- doxytag: member="csl_mmcsd.h::sendCmd" ref="ga770b1ccb0e958bf9ce380bd3e8f71ed7" args="(CSL_MmcsdHandle hMmcsd, CSL_MmcsdCmd *cmd, Uint32 argument)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status sendCmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__MMCControllerObj.html">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__MmcsdCmd.html">CSL_MmcsdCmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends command. </p>
<p>This API sends command to the card. The commands are w.r.t. MMC/SD specification</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] command details </td></tr>
    <tr><td class="paramname">argument</td><td>[IN] argument value for the command</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CSL_Status </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 27 2013 13:32:43 for C55XX CSL LP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
