<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>C55XX CSL LP: USB MUSB Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">C55XX CSL LP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB MUSB Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__CSL__USB__API.html">USB</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaf7b44f92890da9de9607c7537960d42a">USB_init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga8c105f688a92a1205f4840a0ce768cdb">USB_open</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga576adaba91ba84a9940c9d5bced322d0">USB_config</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, <a class="el" href="structCSL__UsbConfig.html">CSL_UsbConfig</a> *usbCfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga3ecd6973c919ea9f9315f953802dfc1b">USB_requestEndpt</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, <a class="el" href="group__CSL__USB__ENUM.html#gadd63cd53e03e1d7e632a8cbe348e3401">CSL_UsbEpNum</a> epNum, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaa6fdc35d5574b4f2b75c19bfdf54c809">USB_releaseEndpt</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga2fae50e5d3f6cf1a9561eb77f50c1be9">USB_configEndpt</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp, <a class="el" href="structCSL__UsbEpConfig.html">CSL_UsbEpConfig</a> *epCfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga24d5e966fe13a5195d5f6c5d3348721d">USB_resetDev</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__SYMBOL.html#ga87072d6bc79ccd6147812c988d653284">CSL_UsbEventMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga6f812786961ae595dd94e9be4d743c9b">USB_getEvents</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__SYMBOL.html#ga87072d6bc79ccd6147812c988d653284">CSL_UsbEventMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga80f24ac9998b6b2b525ddc080993eee2">USB_peekEvents</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga5285d3e2bb774a37753f271563a870b1">USB_getSetupPacket</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, <a class="el" href="structCSL__UsbSetupStruct.html">CSL_UsbSetupStruct</a> *usbSetup, Bool readFromFifo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga0976835f84a5fedd800c643e6c86703e">USB_postTransaction</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp, Uint16 byteCnt, void *data, <a class="el" href="group__CSL__USB__SYMBOL.html#ga451c5b10120bc3d838c3768571f5255c">CSL_UsbIoFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaa43f74a858cb4c895e146b75cbf44ab9">USB_isTransactionDone</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__SYMBOL.html#gab3da07d7e14ff698e33affd67b90e462">CSL_UsbByteCount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga9813c376c0344d96df5368d7918b26f1">USB_bytesRemaining</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaa1befea5ae93ae7079e52df923a54c21">USB_stallEndpt</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaa9238a073828f83b3fc474f183d53677">USB_clearEndptStall</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gadad6e2731853b7b0edeb2fd65dc24fd0">USB_getEndptStall</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga8a8cddf9f5bb46860bcb0177910d438b">USB_epNumToHandle</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, Uint16 endpt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga5986dca460b9e5de21949bb60df1f045">USB_abortTransaction</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gad84fa0939bd8087985097e5834165345">USB_abortAllTransaction</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga4e06dd55c838a3831f0d3944c2838a76">USB_connectDev</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga849ec97e843d099e2a4efe29491c6f5b">USB_disconnectDev</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga697ac4bdefb5d3c8cbd3bcead1e0b23b">USB_setRemoteWakeup</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, <a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a> rmtWkpStat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga3a1737f1a1f76b2cd16120376ba777a1">USB_getRemoteWakeupStat</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga09a70fa94fdc19f7b55637b85746eb38">USB_issueRemoteWakeup</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, Bool resumeBitVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga25cb72d6bce692e49d554479df7c9173">USB_setDevAddr</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, Uint16 addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__SYMBOL.html#gaf3bbf88b130333432b790039b6caf5a3">CSL_UsbFrameNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga12a78752d06d2d937a0bafc181bb1445">USB_getFrameNo</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga41dec8edb199fdb574597228bf8b31fd">USB_suspendDevice</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga3d234787552dafd798c61094fd77f6d2">USB_selfwakeup</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, Uint32 wakeupDelay)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga48dfe90c50e4929e45e5b6d700c6cf38">USB_initPLL</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaafa1e6c7205ddf72f3fed97b0b2a3adb">USB_setParams</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, <a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEpObj[], Uint16 pSofTmrCnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga7b802f35e55c007462fa04cc7d66e9e1">USB_getMaxPower</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga6662427282d4c0a684887dfcd7112ec9">USB_setFullSpeedMode</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, Uint16 ep0DataSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gab2fb9c235d6458e544f2ab573605072a">USB_getDataCountReadFromFifo</a> (<a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga6ba3805bdc6a92c54ebd610184d087f9">USB_findFifoSize</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, Uint16 maxPktSize, <a class="el" href="group__CSL__USB__ENUM.html#ga66eb2483fddc8df328af8db4dca5cde0">CSL_UsbXferType</a> xferType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga6480a43be61686e03ee6d61bd59eb528">USB_coreEventProcessEp0</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processing all the EP0 events for enumeration call the CDC event handler for further processing.  <a href="#ga6480a43be61686e03ee6d61bd59eb528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaf81115692729a4f51bdd61e391bde2f7">USB_swapWords</a> (Uint16 *dataBuffer, Uint32 dataLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga617c12b1a886b29e550e006556a4f379">USB_initDma</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaf1e70d7868d0da0abf71644d86863de0">USB_initQueueManager</a> (<a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *hpdtx, Uint32 *pLinkingRam)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga060b37017cf03824b93f431b550c8594">USB_dmaPopQue</a> (Uint16 queueNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga0ce6eaf5d8091633557b37df2bfae19a">USB_dmaRxStart</a> (DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gafddd09a5cff47ba64c04df2e55a80bff">USB_confDmaRx</a> (<a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *hpdrx, Uint32 packetsize, Uint16 *pRxBuffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga4e893d3e2d0c2beb2b646e4674544337">USB_confDmaTx</a> (DWORD dwEndpoint, <a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *hpdtx, Uint32 packetsize, Uint16 *pTxBuffer, Bool swapWords)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga20e4e8227fc3b0678345d88b40ff4bf0">USB_dmaRxStop</a> (DWORD dwEndpoint, Uint16 *pRxBuffer, Uint32 packetsize, Bool swapWords)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga114e2c5f9ce4007fb69ce865dd9d2a36">USB_dmaTxStart</a> (DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga3569b5b61f6d08666713987ccf3504d9">USB_dmaTxStop</a> (DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga8a2c13e49d2995149afd512bd7812764">USB_handleTx</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaca3d63361bb634ae43a91bb2bce981e0">USB_handleRx</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga438a379bdbb16eda9c901bdce17d7d7c">USB_processEP0Out</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga3c40beb844907883d2bf1e00b59c8f38">USB_processEP0In</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gafc0eaeaae10c704e1562de1168f93068">USB_handleRxIntr</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga1c8bacb1cba9250ed5112cbab087e225">USB_handleTxIntr</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga330ee13ae5b005f56238f7c7b0398bdb">USB_checkSpeed</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, <a class="el" href="group__CSL__USB__ENUM.html#ga6220edfa1c5d35fdc5ccd13caf6e2abe">CSL_UsbBusSpeed</a> *pBusSpeed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gafbb915c8c995a8b752653345fe32f2ef">USB_readEP0Buf</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, DWORD *pBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga2afe1be9825d404c775e8570b85338c2">USB_setConfiguration</a> (<a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> hUsbDev, Uint16 confVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga738d92af63ce8891b61a6b6f899bad78">USB_isValidDataInFifoOut</a> (<a class="el" href="structCSL__UsbEpStatus.html">pUsbEpStatus</a> peps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gae70a92d926f2bb1fe4398a3c3d5da1e1">USB_flushFifo</a> (DWORD dwEndpoint, Bool fifoDirFlag)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad84fa0939bd8087985097e5834165345"></a><!-- doxytag: member="csl_usb.h::USB_abortAllTransaction" ref="gad84fa0939bd8087985097e5834165345" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_abortAllTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_abortAllTransaction</b> </p>
<p><b>Description</b> <br/>
 This function terminates all the data transfer in progress and free up the endpoints to post new data transfer requests.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev         USB device handle
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_postTransaction function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Aborts all transactions in progress</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            ....
			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			.....
			status = USB_abortAllTransaction(hUsbDev);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga5986dca460b9e5de21949bb60df1f045"></a><!-- doxytag: member="csl_usb.h::USB_abortTransaction" ref="ga5986dca460b9e5de21949bb60df1f045" args="(CSL_UsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_abortTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_abortTransaction</b> </p>
<p><b>Description</b> <br/>
 This function terminates the data transfer in progress and free up the endpoint to post a new data transfer request.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_postTransaction function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Terminates data transfer in progress</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            ....
			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			.....
			status = USB_abortTransaction(hEp);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__MSC__FUNCTION.html#gaf0cd33f55ed273163c24d04654c7903e">MSC_HandleStateReset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9813c376c0344d96df5368d7918b26f1"></a><!-- doxytag: member="csl_usb.h::USB_bytesRemaining" ref="ga9813c376c0344d96df5368d7918b26f1" args="(CSL_UsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__SYMBOL.html#gab3da07d7e14ff698e33affd67b90e462">CSL_UsbByteCount</a> USB_bytesRemaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_bytesRemaining</b> </p>
<p><b>Description</b> <br/>
 This API returns number of bytes waiting to be transferred from the previously posted data transfer request.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbByteCount <br/>
 Number of bytes waiting to be transferred</p>
<p><b> Pre Condition </b> <br/>
 Post transaction API should be called successfully</p>
<p><b> Post Condition </b> <br/>
 1. Returns the number of bytes waiting <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            ....
			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			...
			...
			byteCount = USB_bytesRemaining(hEp ,&amp;status);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga330ee13ae5b005f56238f7c7b0398bdb"></a><!-- doxytag: member="csl_usbAux.h::USB_checkSpeed" ref="ga330ee13ae5b005f56238f7c7b0398bdb" args="(CSL_UsbDevHandle hUsbDev, CSL_UsbBusSpeed *pBusSpeed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Bool USB_checkSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#ga6220edfa1c5d35fdc5ccd13caf6e2abe">CSL_UsbBusSpeed</a> *&#160;</td>
          <td class="paramname"><em>pBusSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_checkSpeed</b> </p>
<p><b>Description</b> <br/>
 This function checks the USB bus speed</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev       -   USB device handle
 	        pBusSpeed     -   USB Bus speed variable pointer
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>TRUE - Bus speed is valid </li>
<li>FALSE - Bus speed is invalid</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Checks the USB bus speed</p>
<p><b>Modifies</b> <br/>
 Bus speed variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			busSpeedStat = USB_checkSpeed(hUsbDev, hUsbDev-&gt;busSpeed);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__ENUM.html#gga6220edfa1c5d35fdc5ccd13caf6e2abeac0844d04f362fbed1e21be67189bb4ba">CSL_USB_BS_FULL_SPEED</a>, and <a class="el" href="group__CSL__USB__ENUM.html#gga6220edfa1c5d35fdc5ccd13caf6e2abea40b666f703e973729f2f600a2be43f69">CSL_USB_BS_HIGH_SPEED</a>.</p>

</div>
</div>
<a class="anchor" id="gaa9238a073828f83b3fc474f183d53677"></a><!-- doxytag: member="csl_usb.h::USB_clearEndptStall" ref="gaa9238a073828f83b3fc474f183d53677" args="(CSL_UsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_clearEndptStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_clearEndptStall</b> </p>
<p><b>Description</b> <br/>
 This function clears an end point stall</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj and USB_stallEndpt should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Clears an end point stall</p>
<p><b>Modifies</b> <br/>
 USB control registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            ....
			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			....
			....
			status = USB_stallEndpt(hEp);
			....
			....
			status = USB_clearEndptStall(hEp);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gafd88f11be6f4a4df6adf684900374f21">AC_reqClearFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gab50d37c060294de0581f17672da8d7c6">CDC_reqClearFeature()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga3d5720b2087c7b397a172a04eb984ba0">HID_reqClearFeature()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#gadda22cfca94fe72f4b0f72794512ec55">MSC_reqClearFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="gafddd09a5cff47ba64c04df2e55a80bff"></a><!-- doxytag: member="csl_usbAux.h::USB_confDmaRx" ref="gafddd09a5cff47ba64c04df2e55a80bff" args="(CSL_UsbHostPktDescr *hpdrx, Uint32 packetsize, Uint16 *pRxBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_confDmaRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *&#160;</td>
          <td class="paramname"><em>hpdrx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>packetsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pRxBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_confDmaRx</b> </p>
<p><b>Description</b> <br/>
 Configures Dma for Data receive</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hpdrx         - Dma host packet descriptor pointer
 	        packetsize    - Size of the packet to receive (In Bytes)
 	        pRxBuffer     - Receive Data Buffer pointer
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initDma and USB_initQueueManager should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Receives the data from an end point</p>
<p><b>Modifies</b> <br/>
 USB Dma registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdrx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdrx);
			....
			....
			USB_confDmaRx(&amp;hpdrx, CSL_USB_DATA_SIZE, usbDataBuf);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbHostPktDescr.html#a86ae9baab7f0074737c728a822c131dc">CSL_UsbHostPktDescr::Buffer0InfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#acd4c5a89efb19d77b4a366ff05651af7">CSL_UsbHostPktDescr::Buffer0InfoWord1</a>, <a class="el" href="csl__error_8h.html#ac5a7875db1e0dec1a927698040b4b182">CSL_ESYS_INVPARAMS</a>, <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1d4591887663511ae649f58598324d55">CSL_USB_16BIT_REG_MASK</a>, <a class="el" href="csl__usbAux_8h.html#a93c9cd1c5b1808a677e131557d137b14">HOST_PACKET_DESCR_TYPE</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#ga12dfc0bac563a7d3bbbf72a56c2555b0">IRQ_globalDisable()</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#gaf3a857c0a33806468646533f050d2ae0">IRQ_globalRestore()</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#acdcd4eb3f577c77ca493352e8740dc11">CSL_UsbHostPktDescr::LinkingWord</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a02678515e20358f23e7dd169901fb3d5">CSL_UsbHostPktDescr::OriginalBuffer0InfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a587f35c62327b3606eb432aee8c84728">CSL_UsbHostPktDescr::OriginalBuffer0InfoWord1</a>, <a class="el" href="csl__usbAux_8h.html#a9236595f3a412bb40dff27d9ecd14956">PACKET_TYPE_FOR_USB</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a4ad1fc4d926f3c2f470ca66086af932c">CSL_UsbHostPktDescr::PacketInfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#ade7ceeaec2d9c689f8f4bd69584611bd">CSL_UsbHostPktDescr::PacketInfoWord1</a>, and <a class="el" href="structCSL__UsbHostPktDescr.html#abc1c0b21280b4713f748a83082bc26e0">CSL_UsbHostPktDescr::PacketInfoWord2</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e893d3e2d0c2beb2b646e4674544337"></a><!-- doxytag: member="csl_usbAux.h::USB_confDmaTx" ref="ga4e893d3e2d0c2beb2b646e4674544337" args="(DWORD dwEndpoint, CSL_UsbHostPktDescr *hpdtx, Uint32 packetsize, Uint16 *pTxBuffer, Bool swapWords)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_confDmaTx </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *&#160;</td>
          <td class="paramname"><em>hpdtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>packetsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pTxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>swapWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_confDmaTx</b> </p>
<p><b>Description</b> <br/>
 Configures Dma for Data USB data transfer. For C5505 PG1.4 and earlier versions of the DSP, word swap is required for the data buffer before transferring the data. Parameter 'swapWords' provides facility to request for the word swap for the data buffer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hpdtx         - Dma host packet descriptor pointer
 	        packetsize    - Size of the packet to transmit (In Bytes)
 	        pTxBuffer     - Data Buffer pointer
			swapWords     - Flag to request for word swap
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initDma and USB_initQueueManager should be called successfully</p>
<p><b> Post Condition </b> <br/>
 transmits data to an end point</p>
<p><b>Modifies</b> <br/>
 USB Dma registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdtx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdrx);
			....
			....
			USB_confDmaTx(&amp;hpdrx, CSL_USB_DATA_SIZE, usbDataBuf);
     </pre></div><p> ============================================================================ </p>

<p><p>hpdtx-&gt;PacketInfoWord1 = 0; </p>
</p>

<p>References <a class="el" href="structCSL__UsbHostPktDescr.html#a86ae9baab7f0074737c728a822c131dc">CSL_UsbHostPktDescr::Buffer0InfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#acd4c5a89efb19d77b4a366ff05651af7">CSL_UsbHostPktDescr::Buffer0InfoWord1</a>, <a class="el" href="csl__error_8h.html#ac5a7875db1e0dec1a927698040b4b182">CSL_ESYS_INVPARAMS</a>, <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1d4591887663511ae649f58598324d55">CSL_USB_16BIT_REG_MASK</a>, <a class="el" href="csl__usbAux_8h.html#a93c9cd1c5b1808a677e131557d137b14">HOST_PACKET_DESCR_TYPE</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#ga12dfc0bac563a7d3bbbf72a56c2555b0">IRQ_globalDisable()</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#gaf3a857c0a33806468646533f050d2ae0">IRQ_globalRestore()</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#acdcd4eb3f577c77ca493352e8740dc11">CSL_UsbHostPktDescr::LinkingWord</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a02678515e20358f23e7dd169901fb3d5">CSL_UsbHostPktDescr::OriginalBuffer0InfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a587f35c62327b3606eb432aee8c84728">CSL_UsbHostPktDescr::OriginalBuffer0InfoWord1</a>, <a class="el" href="csl__usbAux_8h.html#a9236595f3a412bb40dff27d9ecd14956">PACKET_TYPE_FOR_USB</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a4ad1fc4d926f3c2f470ca66086af932c">CSL_UsbHostPktDescr::PacketInfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#ade7ceeaec2d9c689f8f4bd69584611bd">CSL_UsbHostPktDescr::PacketInfoWord1</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#abc1c0b21280b4713f748a83082bc26e0">CSL_UsbHostPktDescr::PacketInfoWord2</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#gaf81115692729a4f51bdd61e391bde2f7">USB_swapWords()</a>.</p>

</div>
</div>
<a class="anchor" id="ga576adaba91ba84a9940c9d5bced322d0"></a><!-- doxytag: member="csl_usb.h::USB_config" ref="ga576adaba91ba84a9940c9d5bced322d0" args="(CSL_UsbDevHandle hUsbDev, CSL_UsbConfig *usbCfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UsbConfig.html">CSL_UsbConfig</a> *&#160;</td>
          <td class="paramname"><em>usbCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_config</b> </p>
<p><b>Description</b> <br/>
 This function configures the USB device</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev          USB device handle
            usbConfig        USB Config structure
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init and USB_open functions should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Configures the USB device</p>
<p><b>Modifies</b> <br/>
 USB context structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevNum    devNum;
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			
            devNum = CSL_USB0;
            .....
            .....
            USB_init();
			hUsbDev = USB_open(devNum);
			status = USB_config(hUsbDev, &amp;usbCfg);			
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga2fae50e5d3f6cf1a9561eb77f50c1be9"></a><!-- doxytag: member="csl_usb.h::USB_configEndpt" ref="ga2fae50e5d3f6cf1a9561eb77f50c1be9" args="(CSL_UsbEpHandle hEp, CSL_UsbEpConfig *epCfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_configEndpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpConfig.html">CSL_UsbEpConfig</a> *&#160;</td>
          <td class="paramname"><em>epCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_configEndpt</b> </p>
<p><b>Description</b> <br/>
 This function configures an endpoint object.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp           Handle to an endpoint object to be initialized.
            *epCfg        Endpoint configuration structure
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init, USB_open, USB_config and USB_requestEndpt functions should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Configures an end point object</p>
<p><b>Modifies</b> <br/>
 End point object and status structures</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevNum    devNum;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
			
            devNum = CSL_USB0;
            .....
            .....
            USB_init();
			hUsbDev = USB_open(devNum);
			status = USB_config(hUsbDev, &amp;usbCfg);			
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga4e06dd55c838a3831f0d3944c2838a76"></a><!-- doxytag: member="csl_usb.h::USB_connectDev" ref="ga4e06dd55c838a3831f0d3944c2838a76" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_connectDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_connectDev</b> </p>
<p><b>Description</b> <br/>
 This function connects the USB module to upstream port</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev         USB device handle
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init function should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Connects the USB module</p>
<p><b>Modifies</b> <br/>
 USB FADDR_POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            status = USB_connectDev(CSL_USB0);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga6480a43be61686e03ee6d61bd59eb528"></a><!-- doxytag: member="csl_usb.h::USB_coreEventProcessEp0" ref="ga6480a43be61686e03ee6d61bd59eb528" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_coreEventProcessEp0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processing all the EP0 events for enumeration call the CDC event handler for further processing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hUsbDev</td><td>[in] USB device handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error Status </dd></dl>

</div>
</div>
<a class="anchor" id="ga849ec97e843d099e2a4efe29491c6f5b"></a><!-- doxytag: member="csl_usb.h::USB_disconnectDev" ref="ga849ec97e843d099e2a4efe29491c6f5b" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_disconnectDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_disconnectDev</b> </p>
<p><b>Description</b> <br/>
 This function disconnects the USB module from the upstream port</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev         USB device handle
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_connectDev should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Disconnects the USB module.</p>
<p><b>Modifies</b> <br/>
 USB FADDR_POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            status = USB_connectDev(hUsbDev);
            ....
            status = USB_disconnectDev(hUsbDev);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga060b37017cf03824b93f431b550c8594"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaPopQue" ref="ga060b37017cf03824b93f431b550c8594" args="(Uint16 queueNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaPopQue </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>queueNum</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaPopQue</b> </p>
<p><b>Description</b> <br/>
 Function to popup the DMA queue. DMA descriptors will be removed from the queue.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        queueNum   - Queue number
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Popup the queue</p>
<p><b>Modifies</b> <br/>
 USB Queue manager registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			USB_dmaPopQue(24);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga0ce6eaf5d8091633557b37df2bfae19a"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaRxStart" ref="ga0ce6eaf5d8091633557b37df2bfae19a" args="(DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaRxStart </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaRxStart</b> </p>
<p><b>Description</b> <br/>
 Starts Dma Receive</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 			dwEndpoint    - Endpoint number that is configured for Rx
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_confDmaRx should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Starts Dma data receive</p>
<p><b>Modifies</b> <br/>
 Data buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdrx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdrx);
			....
			....
			USB_confDmaRx(&amp;hpdrx, CSL_USB_DATA_SIZE, usbDataBuf);
			....
			....
			USB_dmaRxStart();
     </pre></div><p> ============================================================================ </p>

<p><p>MW It clears the wrong bit</p>
<p>MW, need set the DISNYET (bit 12) too </p>
</p>

<p>Referenced by <a class="el" href="group__CSL__USB__FUNCTION.html#gaca3d63361bb634ae43a91bb2bce981e0">USB_handleRx()</a>.</p>

</div>
</div>
<a class="anchor" id="ga20e4e8227fc3b0678345d88b40ff4bf0"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaRxStop" ref="ga20e4e8227fc3b0678345d88b40ff4bf0" args="(DWORD dwEndpoint, Uint16 *pRxBuffer, Uint32 packetsize, Bool swapWords)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaRxStop </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pRxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>packetsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>swapWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaRxStop</b> </p>
<p><b>Description</b> <br/>
 Stops Dma data Receive operation. For C5505 PG1.4 and earlier versions of the DSP, wordswap is required for the data buffer after completing the data reception. Parameter 'swapWords' provides facility to request for the word swap for the data buffer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
			dwEndpoint   - Endpoint number that is configured for Rx
 			pRxBuffer    -   DMA Receive data buffer
			packetsize   -   Size of the data received (In Bytes)
			swapWords    -   Flag to swap the words in the Rx buffer
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_dmaRxStart should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Starts Dma data receive</p>
<p><b>Modifies</b> <br/>
 USB Registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdrx;

			USB_confDmaRx(&amp;hpdrx, CSL_USB_DATA_SIZE, usbDataBuf);
			....
			....
			USB_dmaRxStart();
			...
			...
			USB_dmaRxStop();
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__FUNCTION.html#gaf81115692729a4f51bdd61e391bde2f7">USB_swapWords()</a>.</p>

</div>
</div>
<a class="anchor" id="ga114e2c5f9ce4007fb69ce865dd9d2a36"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaTxStart" ref="ga114e2c5f9ce4007fb69ce865dd9d2a36" args="(DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaTxStart </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaTxStart</b> </p>
<p><b>Description</b> <br/>
 Starts Dma data transmit. DMA should be configure for the data transmit operation before calling this function. Data will be transmitted by the DMA as per the configured values.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 			dwEndpoint    - Endpoint number that is configured for Tx
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_confDmaTx should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Starts Dma data transfer</p>
<p><b>Modifies</b> <br/>
 USB FIFO registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdtx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdtx);
			....
			....
			USB_confDmaTx(&amp;hpdtx, CSL_USB_DATA_SIZE, usbDataBuf);
			....
			....
			USB_dmaTxStart();
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__USB__FUNCTION.html#ga8a2c13e49d2995149afd512bd7812764">USB_handleTx()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3569b5b61f6d08666713987ccf3504d9"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaTxStop" ref="ga3569b5b61f6d08666713987ccf3504d9" args="(DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaTxStop </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaTxStop</b> </p>
<p><b>Description</b> <br/>
 Stops Dma data transmit.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 			dwEndpoint    - Endpoint number that is configured for Tx
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_dmaTxStart should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Stops Dma data receive</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdtx;

			USB_confDmaTx(&amp;hpdtx, CSL_USB_DATA_SIZE, usbDataBuf);
			....
			....
			USB_dmaTxStart();
			...
			...
			USB_dmaTxStop();
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga8a8cddf9f5bb46860bcb0177910d438b"></a><!-- doxytag: member="csl_usb.h::USB_epNumToHandle" ref="ga8a8cddf9f5bb46860bcb0177910d438b" args="(CSL_UsbDevHandle hUsbDev, Uint16 endpt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> USB_epNumToHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>endpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_epNumToHandle</b> </p>
<p><b>Description</b> <br/>
 This function returns handle to an end point</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev       USB device handle
            endPt         16-bit endpoint number as specified
 						  in the USB specification.
 						  0x00 -&gt; Endpt 0 Out.
 						  0x01 -&gt; Endpt 1 Out.
          				  0x80 -&gt; Endpt 0 In.
          				  0x81 -&gt; Endpt 1 In.
     </pre></div><p><b> Return Value </b> CSL_UsbEpHandle <br/>
 Handle to the endpoint object if a valid endpoint object exists, else NULL object.</p>
<p><b> Pre Condition </b> <br/>
 USB_init function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 returns End point handle</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_epNumToHandle(hUsbDev, CSL_USB_IN_TRANSFER);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gafd88f11be6f4a4df6adf684900374f21">AC_reqClearFeature()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga9a8bc1b593ae63a89fa2b788f35c11ca">AC_reqGetStatus()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga6f843961b00fa217e2d82ad5020d0364">AC_reqSetFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gab50d37c060294de0581f17672da8d7c6">CDC_reqClearFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gabdd172dbd2208f7ac38e67678b545b68">CDC_reqGetStatus()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gac5d1da006cea04d5f8785832dad2fbdb">CDC_reqSetFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gadda22cfca94fe72f4b0f72794512ec55">MSC_reqClearFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gab25fc52b3701ce63235407366df10eed">MSC_reqGetStatus()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#ga36d52d670751ab36289b5b9c5eda7578">MSC_reqSetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6ba3805bdc6a92c54ebd610184d087f9"></a><!-- doxytag: member="csl_usb.h::USB_findFifoSize" ref="ga6ba3805bdc6a92c54ebd610184d087f9" args="(CSL_UsbDevHandle hUsbDev, Uint16 maxPktSize, CSL_UsbXferType xferType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 USB_findFifoSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>maxPktSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#ga66eb2483fddc8df328af8db4dca5cde0">CSL_UsbXferType</a>&#160;</td>
          <td class="paramname"><em>xferType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_findFifoSize</b> </p>
<p><b>Description</b> <br/>
 Determine the fifo size according to the transfer type and the maximum packet size</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev         USB device handle
            maxPktSize      Maximum packet size
            xferType        Transfer type
     </pre></div><p><b> Return Value </b> FIFO size</p>
<p><b> Pre Condition </b> <br/>
 USB_init and USB_open function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns FIFO size</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevHandle hUsbDev
			Uint16           fifoSize;
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
            .....	
            fifoSize = USB_findFifoSize(hUsbDev, 64);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="gae70a92d926f2bb1fe4398a3c3d5da1e1"></a><!-- doxytag: member="csl_usbAux.h::USB_flushFifo" ref="gae70a92d926f2bb1fe4398a3c3d5da1e1" args="(DWORD dwEndpoint, Bool fifoDirFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_flushFifo </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>fifoDirFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_flushFifo</b> </p>
<p><b>Description</b> <br/>
 Function to flush the Tx and Rx FIFO of the USB</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        dwEndpoint  - End point to which FIFO flush is required
 	        fifoDirFlag - Flag to indicate the FIFO direction
 	                      1 - Tx FIFO, 0 - Rx FIFO
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Flushes Tx/Rx FIFO</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            //Flush Tx FIFO
			USB_flushFifo (CSL_USB_EP1, 1);

            //Flush Rx FIFO
			USB_flushFifo (CSL_USB_EP2, 0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>.</p>

</div>
</div>
<a class="anchor" id="gab2fb9c235d6458e544f2ab573605072a"></a><!-- doxytag: member="csl_usb.h::USB_getDataCountReadFromFifo" ref="gab2fb9c235d6458e544f2ab573605072a" args="(CSL_UsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 USB_getDataCountReadFromFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getDataCountReadFromFifo</b> </p>
<p><b>Description</b> <br/>
 This function returns the most recent data count read from the FIFO. This function is supposed to use for the OUT end point. This function always return 0 for IN end point.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> Data count read from FIFO</p>
<p><b> Pre Condition </b> <br/>
 End point object should be initialized</p>
<p><b> Post Condition </b> <br/>
 Terminates data transfer in progress</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevHandle hUsbDev
			CSL_UsbEpHandle  hEp
			CSL_UsbEventMask usbEvents;
			CSL_Status       *status
			Uint16           fifoDataCount;
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
            .....		
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            .....	
            fifoDataCount = USB_getDataCountReadFromFifo(hEp);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__MSC__FUNCTION.html#ga326bb71633b4d09620ab0396d0e4457d">MSC_verifyCBW()</a>.</p>

</div>
</div>
<a class="anchor" id="gadad6e2731853b7b0edeb2fd65dc24fd0"></a><!-- doxytag: member="csl_usb.h::USB_getEndptStall" ref="gadad6e2731853b7b0edeb2fd65dc24fd0" args="(CSL_UsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a> USB_getEndptStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getEndptStall</b> </p>
<p><b>Description</b> <br/>
 This function checks if an endpoint is stalled.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbBoolean </p>
<ul>
<li>CSL_USB_TRUE - If the end point is stalled. </li>
<li>CSL_USB_FALSE - If the end point is not stalled</li>
</ul>
<p><b> Pre Condition </b> <br/>
 Init End point API should be called successfully</p>
<p><b> Post Condition </b> <br/>
 1. Returns the end point stall status <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			...
			...
			epStall = USB_getEndptStall(hEp, &amp;status);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga9a8bc1b593ae63a89fa2b788f35c11ca">AC_reqGetStatus()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gabdd172dbd2208f7ac38e67678b545b68">CDC_reqGetStatus()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga45d6740c6e6fe2028c9feb4a85fd5474">HID_reqGetStatus()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#gab25fc52b3701ce63235407366df10eed">MSC_reqGetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f812786961ae595dd94e9be4d743c9b"></a><!-- doxytag: member="csl_usb.h::USB_getEvents" ref="ga6f812786961ae595dd94e9be4d743c9b" args="(CSL_UsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__SYMBOL.html#ga87072d6bc79ccd6147812c988d653284">CSL_UsbEventMask</a> USB_getEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getEvents</b> </p>
<p><b>Description</b> <br/>
 This API reads and clears all the pending USB_EVENTS associated with a particular USB endpoint.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbEventMask <br/>
 ORed combination of all the pending USB_EVENTS associated with a particular endpoint.</p>
<p><b> Pre Condition </b> <br/>
 End point object should be initialized</p>
<p><b> Post Condition </b> <br/>
 1. Clears and returns the end point events <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevHandle hUsbDev
			CSL_UsbEpHandle  hEp
			CSL_UsbEventMask usbEvents;
			CSL_Status       *status
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
            .....		
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            .....
            usbEvents = USB_getEvents(hEp, &amp;status);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga12a78752d06d2d937a0bafc181bb1445"></a><!-- doxytag: member="csl_usb.h::USB_getFrameNo" ref="ga12a78752d06d2d937a0bafc181bb1445" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__SYMBOL.html#gaf3bbf88b130333432b790039b6caf5a3">CSL_UsbFrameNum</a> USB_getFrameNo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getFrameNo</b> </p>
<p><b>Description</b> <br/>
 This function reads current USB frame number</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev         USB device handle
     </pre></div><p><b> Return Value </b> CSL_UsbFrameNum <br/>
 Current USB frame number</p>
<p><b> Pre Condition </b> <br/>
 USB init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns the frame number</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            ....
            status = USB_getFrameNo(hUsbDev);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga7b802f35e55c007462fa04cc7d66e9e1"></a><!-- doxytag: member="csl_usb.h::USB_getMaxPower" ref="ga7b802f35e55c007462fa04cc7d66e9e1" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD USB_getMaxPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getMaxPower</b> </p>
<p><b>Description</b> <br/>
 This function returns the maximum current drawn by the device. This is to inform the host about the device power requirement. This value is passed to the host through the configuration descriptor.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev     USB device handle
     </pre></div><p><b> Return Value </b> Maximum current drawn by the device</p>
<p><b> Pre Condition </b> <br/>
 USB_init function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns the maximum current drawn by the device</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            .....
            maxPower = USB_getMaxPower(hUsbDev);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga3a1737f1a1f76b2cd16120376ba777a1"></a><!-- doxytag: member="csl_usb.h::USB_getRemoteWakeupStat" ref="ga3a1737f1a1f76b2cd16120376ba777a1" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a> USB_getRemoteWakeupStat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getRemoteWakeupStat</b> </p>
<p><b>Description</b> <br/>
 This function returns the remote wake up feature status.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev         USB device handle
     </pre></div><p><b> Return Value </b> CSL_UsbBoolean </p>
<ul>
<li>CSL_USB_TRUE - Remote wakeup feature is enabled. </li>
<li>CSL_USB_FALSE - Remote wakeup feature is disabled.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_setRemoteWakeup function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns remote wakeup status</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_Status        status;
            CSL_UsbBoolean    rmtWkpStat

            status = USB_setRemoteWakeup(hUsbDev, CSL_USB_TRUE);

            if(status == CSL_SOK)
            {
		        rmtWkpStat = USB_getRemoteWakeupStat(hUsbDev);
			}
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga9a8bc1b593ae63a89fa2b788f35c11ca">AC_reqGetStatus()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gabdd172dbd2208f7ac38e67678b545b68">CDC_reqGetStatus()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga45d6740c6e6fe2028c9feb4a85fd5474">HID_reqGetStatus()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#gab25fc52b3701ce63235407366df10eed">MSC_reqGetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5285d3e2bb774a37753f271563a870b1"></a><!-- doxytag: member="csl_usb.h::USB_getSetupPacket" ref="ga5285d3e2bb774a37753f271563a870b1" args="(CSL_UsbDevHandle hUsbDev, CSL_UsbSetupStruct *usbSetup, Bool readFromFifo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_getSetupPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UsbSetupStruct.html">CSL_UsbSetupStruct</a> *&#160;</td>
          <td class="paramname"><em>usbSetup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>readFromFifo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getSetupPacket</b> </p>
<p><b>Description</b> <br/>
 This function read the setup packet from the setup data buffer. This function can be used to read the setup packet from the FIFO or we can read the setup packet from the USB context structure. We can choose one of two options using readFromFifo parameter. If readFromFifo is TRUE setup packet is read from the FIFO. If readFromFifo is FALSE setup packet is read from the context structure. Setup packet should be read from FIFO when this function is called from interrupt handler(In this case read packet is stored in context structure) and setup packet should be read from USB context structure when this function is called from MSC layer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev        USB device handle
            usbSetup       Pointer to setup structure
			readFromFifo   TRUE if setup packet should be read from FIFO
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init and USB_open should be called successfully</p>
<p><b> Post Condition </b> <br/>
 USB setup structure is populated</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevHandle      hUsbDev
            CSL_UsbSetupStruct    usbSetup;
            CSL_Status            status;
            CSL_UsbConfig         usbConfig

            USB_init();
			hUsbDev = USB_open(CSL_USB0);
            ....
            ....
            status = USB_getSetupPacket(hUsbDev, &amp;usbSetup , TRUE);

     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="gaca3d63361bb634ae43a91bb2bce981e0"></a><!-- doxytag: member="csl_usbAux.h::USB_handleRx" ref="gaca3d63361bb634ae43a91bb2bce981e0" args="(CSL_UsbDevHandle hUsbDev, DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_handleRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_handleRx</b> </p>
<p><b>Description</b> <br/>
 Receives the data over the non-control end points This function can read the data in polled mode or using CPPI DMA. For the DMA mode operation opmode needs to be set to DMA using <a class="el" href="group__CSL__USB__FUNCTION.html#gaf7b44f92890da9de9607c7537960d42a">USB_init()</a> API and CPPI DMA needs to be configured for USB Rx operation using <a class="el" href="group__CSL__USB__FUNCTION.html#gafddd09a5cff47ba64c04df2e55a80bff">USB_confDmaRx()</a> API before calling this function.</p>
<p>USB DMA will be used when the data to be received is 64 or 512 bytes. CPU will be used to receive any other length of data.</p>
<p>Data to be recived will be read from the Rx FIFO one packet at a time. Legth of the packet will be decided based on the maximum packet size assigned to the Rx FIFO. In case of poll mode operation complete transfer callback function will be invoked after reading all the packets from the Rx FIFO. In case of DMA mode operation complete transfer callback will be invoked for each packet read. Complete transfer callback function is supposed to wait for DMA transfer completion.</p>
<p>Number of bytes read from FIFO in each transaction will be stored in 'pTransfer-&gt;prevTxferLen'. This value will be 64 or 512 when DMA mode is enabled and DMA is used for the data transfer. Other cases indicates that CPU mode is enabled or CPU is used for data transfer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev       -   USB device handle
 	        dwEndpoint    -   End point number
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Reads data from an end point</p>
<p><b>Modifies</b> <br/>
 USB Data buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			status = USB_handleRx(hUsbDev, CSL_USB_EP2);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="csl__error_8h.html#ac5a7875db1e0dec1a927698040b4b182">CSL_ESYS_INVPARAMS</a>, <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae2f228461fa9c4e40849cc426a9eb3e8">CSL_USB_MIN</a>, <a class="el" href="structCSL__UsbEpStatus.html#a494f02bbd449b9d0160746e74d314d67">CSL_UsbEpStatus::dwPacketSizeAssigned</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#ade5fc0a02836f9927de5fe486b9d17b2">CSL_UsbContext::fWaitingOnFlagB</a>, <a class="el" href="structCSL__UsbContext.html#a224b01404788a137bcb30877fc57f098">CSL_UsbContext::opMode</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbEpStatus.html#a9ed323d5ed5ba2ce5579ccaf4b4d6d3e">CSL_UsbEpStatus::pFifoAddr</a>, <a class="el" href="structCSL__UsbTransfer.html#ac4c77b234b43d2ed991f488ac9e932b3">CSL_UsbTransfer::prevTxferLen</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga0ce6eaf5d8091633557b37df2bfae19a">USB_dmaRxStart()</a>, and <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>.</p>

</div>
</div>
<a class="anchor" id="gafc0eaeaae10c704e1562de1168f93068"></a><!-- doxytag: member="csl_usbAux.h::USB_handleRxIntr" ref="gafc0eaeaae10c704e1562de1168f93068" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_handleRxIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_handleRxIntr</b> </p>
<p><b>Description</b> <br/>
 This function handles USb receive interrupts. This function is provided to be used with MSC module. For standalone MUSB operation this function is not required This function works only if EP2 configured for Rx</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev      -  USB device handle
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Handles Rx interrupt</p>
<p><b>Modifies</b> <br/>
 USb registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			status = USB_handleRxIntr(hUsbDev);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="structCSL__UsbContext.html#a3c64343858b027690cc8918c26464de3">CSL_UsbContext::fSetupPktCmd</a>, <a class="el" href="structCSL__UsbContext.html#ade5fc0a02836f9927de5fe486b9d17b2">CSL_UsbContext::fWaitingOnFlagB</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a2c13e49d2995149afd512bd7812764"></a><!-- doxytag: member="csl_usbAux.h::USB_handleTx" ref="ga8a2c13e49d2995149afd512bd7812764" args="(CSL_UsbDevHandle hUsbDev, DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_handleTx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_handleTx</b> </p>
<p><b>Description</b> <br/>
 Transmits the data over the non-control end points. This function can transmit the data in polled mode or using CPPI DMA. For the DMA mode operation opmode needs to be set to DMA using <a class="el" href="group__CSL__USB__FUNCTION.html#gaf7b44f92890da9de9607c7537960d42a">USB_init()</a> API and CPPI DMA needs to be configured for USB Tx operation using <a class="el" href="group__CSL__USB__FUNCTION.html#ga4e893d3e2d0c2beb2b646e4674544337">USB_confDmaTx()</a> API before calling this function.</p>
<p>USB DMA will be used when the data to be transferred is 64 or 512 bytes. CPU will be used to transfer any other length of data.</p>
<p>Data to be sent will be copied to the Tx FIFO one packet at a time. Legth of the packet will be decided based on the maximum packet size assigned to the Tx FIFO. In case of poll mode operation complete transfer callback function will be invoked after copying all the packets to the Tx FIFO. In case of DMA mode operation complete transfer callback will be invoked for each packet transferred. Complete transfer callback function is supposed to wait for DMA transfer completion.</p>
<p>Number of bytes written to FIFO in each transaction will be stored in 'pTransfer-&gt;prevTxferLen'. This value will be 64 or 512 when DMA mode is enabled and DMA is used for the data transfer. Other cases indicates that CPU mode is enabled or CPU is used for data transfer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev       -   USB device handle
 	        dwEndpoint    -   End point number
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Writes data to an end point</p>
<p><b>Modifies</b> <br/>
 USB FIFO registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			status = USB_handleTx(hUsbDev, CSL_USB_EP1);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="csl__error_8h.html#ac5a7875db1e0dec1a927698040b4b182">CSL_ESYS_INVPARAMS</a>, <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gaaff45fadbb316cd141ef34a431d2f30b">CSL_USB_IOFLAG_NOT</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae2f228461fa9c4e40849cc426a9eb3e8">CSL_USB_MIN</a>, <a class="el" href="structCSL__UsbEpStatus.html#a494f02bbd449b9d0160746e74d314d67">CSL_UsbEpStatus::dwPacketSizeAssigned</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbEpStatus.html#ae46604885557d80bc41bef180d471463">CSL_UsbEpStatus::fStalled</a>, <a class="el" href="structCSL__UsbContext.html#ae6eee30c7137ffb78edcb20b8b07dbf2">CSL_UsbContext::fWaitingOnFlagA</a>, <a class="el" href="structCSL__UsbTransfer.html#afc697a9b294d75bf57a7e0d6c03a18e8">CSL_UsbTransfer::ioFlags</a>, <a class="el" href="structCSL__UsbContext.html#a224b01404788a137bcb30877fc57f098">CSL_UsbContext::opMode</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbEpStatus.html#a9ed323d5ed5ba2ce5579ccaf4b4d6d3e">CSL_UsbEpStatus::pFifoAddr</a>, <a class="el" href="structCSL__UsbTransfer.html#ac4c77b234b43d2ed991f488ac9e932b3">CSL_UsbTransfer::prevTxferLen</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga114e2c5f9ce4007fb69ce865dd9d2a36">USB_dmaTxStart()</a>, and <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c8bacb1cba9250ed5112cbab087e225"></a><!-- doxytag: member="csl_usbAux.h::USB_handleTxIntr" ref="ga1c8bacb1cba9250ed5112cbab087e225" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_handleTxIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_handleTxIntr</b> </p>
<p><b>Description</b> <br/>
 This function handles USB transmit interrupts.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev      -  USB device handle
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Handles Tx interrupt</p>
<p><b>Modifies</b> <br/>
 USb registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			status = USB_handleTxIntr(hUsbDev);
     </pre></div><p> ============================================================================ </p>

<p><p>usbRegisters-&gt;INDEX_TESTMODE |= CSL_USB_EP1; </p>
</p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>.</p>

</div>
</div>
<a class="anchor" id="gaf7b44f92890da9de9607c7537960d42a"></a><!-- doxytag: member="csl_usb.h::USB_init" ref="gaf7b44f92890da9de9607c7537960d42a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_init</b> </p>
<p><b>Description</b> <br/>
 This function initializes USB module</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            None
     </pre></div><p><b> Return Value </b> <br/>
 None</p>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Initializes the USB module</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            USB_init();
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga617c12b1a886b29e550e006556a4f379"></a><!-- doxytag: member="csl_usbAux.h::USB_initDma" ref="ga617c12b1a886b29e550e006556a4f379" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_initDma </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_initDma</b> </p>
<p><b>Description</b> <br/>
 Initializes the Dma</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
			None
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Initializes USB Dma</p>
<p><b>Modifies</b> <br/>
 USB Dma registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			USB_init();
			....
			....
			USB_initDma();
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga22355774f2a54915f2161723179ff840">CSL_USB_RXGCR1_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga16496a0530c41e0a1d909d5904b9f139">CSL_USB_RXGCR2_DEFVAL</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#ga12dfc0bac563a7d3bbbf72a56c2555b0">IRQ_globalDisable()</a>, and <a class="el" href="group__CSL__INTC__FUNCTION.html#gaf3a857c0a33806468646533f050d2ae0">IRQ_globalRestore()</a>.</p>

</div>
</div>
<a class="anchor" id="ga48dfe90c50e4929e45e5b6d700c6cf38"></a><!-- doxytag: member="csl_usb.h::USB_initPLL" ref="ga48dfe90c50e4929e45e5b6d700c6cf38" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_initPLL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_initPLL</b> </p>
<p><b>Description</b> <br/>
 Initializes PLL for USB operation. This function initializes the PLL to 100 MHz. For configuring PLL to any other frequency use PLL module.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
                   None
     </pre></div><p><b> Return Value </b> None <br/>
</p>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Initializes PLL</p>
<p><b>Modifies</b> <br/>
 PLL registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			USB_initPLL();
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="gaf1e70d7868d0da0abf71644d86863de0"></a><!-- doxytag: member="csl_usbAux.h::USB_initQueueManager" ref="gaf1e70d7868d0da0abf71644d86863de0" args="(CSL_UsbHostPktDescr *hpdtx, Uint32 *pLinkingRam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_initQueueManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *&#160;</td>
          <td class="paramname"><em>hpdtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pLinkingRam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_initQueueManager</b> </p>
<p><b>Description</b> <br/>
 Initializes the Dma queue manager.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hpdtx         - Dma host packet transmit descriptor pointer
			pLinkingRam   - Pointer to linking RAM data buffer
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initDma should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Initializes queue manager</p>
<p><b>Modifies</b> <br/>
 USB Queue manager registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbHostPacketDescriptor    hpdtx;
			USB_init();
			....
			....
			USB_initDma();
			USB_initQueueManager(&amp;hpdrx);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="csl__error_8h.html#ac5a7875db1e0dec1a927698040b4b182">CSL_ESYS_INVPARAMS</a>, <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1d4591887663511ae649f58598324d55">CSL_USB_16BIT_REG_MASK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga85fecdcffe96ec468d83172a9316a2b5">CSL_USB_16BIT_REG_SHIFT</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae283f0564c96e38133010685aad3a70e">CSL_USB_LRAM0SIZE_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga9e195110e2f68b36ae203faf12a113ce">CSL_USB_QMEMRCTRL2_DEFVAL</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#ga12dfc0bac563a7d3bbbf72a56c2555b0">IRQ_globalDisable()</a>, and <a class="el" href="group__CSL__INTC__FUNCTION.html#gaf3a857c0a33806468646533f050d2ae0">IRQ_globalRestore()</a>.</p>

</div>
</div>
<a class="anchor" id="ga09a70fa94fdc19f7b55637b85746eb38"></a><!-- doxytag: member="csl_usb.h::USB_issueRemoteWakeup" ref="ga09a70fa94fdc19f7b55637b85746eb38" args="(CSL_UsbDevHandle hUsbDev, Bool resumeBitVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_issueRemoteWakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>resumeBitVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_issueRemoteWakeup</b> </p>
<p><b>Description</b> <br/>
 This function issues a remote wakeup signal to the host. NOTE: For remote wakeup protocol application program needs to call this function two times. In the first call resumeBitVal should be TRUE and in the second call resumeBitVal should be FALSE. Application should give a delay of 2 - 15 mSecs between the two calls. This is to avoid delays internal to the CSL module</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev          USB device handle
            resumeBitVal     Value of the resume bit - TRUE or FALSE
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_setRemoteWakeup function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Issues a remote wake up signal.</p>
<p><b>Modifies</b> <br/>
 USB FADDR POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_Status    status;

            status = USB_setRemoteWakeup(hUsbDev, CSL_USB_TRUE);

            if(status == CSL_SOK)
            {
		        status = USB_issueRemoteWakeup(hUsbDev, TRUE);
			}
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="gaa43f74a858cb4c895e146b75cbf44ab9"></a><!-- doxytag: member="csl_usb.h::USB_isTransactionDone" ref="gaa43f74a858cb4c895e146b75cbf44ab9" args="(CSL_UsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a> USB_isTransactionDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_isTransactionDone</b> </p>
<p><b>Description</b> <br/>
 This function returns the status of the previously posted data transfer request.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbBoolean </p>
<ul>
<li>CSL_USB_TRUE - If the previously posted transfer is completed. </li>
<li>CSL_USB_FALSE - If the previously posted transfer is not completed.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 Post transaction API should be called successfully</p>
<p><b> Post Condition </b> <br/>
 1. Returns the previous transaction status <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            ....
			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			...
			...
			tscStatus = USB_isTransactionDone(hEp ,&amp;status);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__MSC__FUNCTION.html#gae0cf7468d0df0233275984398dd072f7">MSC_HandleStateSendCSW()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga365f33f75e7ded19a489336acf61bd1b">MSC_HandleStateSendData()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#gac6f1b38df1c546ae0f9bbb82e5029b81">MSC_HandleStateSendStall()</a>.</p>

</div>
</div>
<a class="anchor" id="ga738d92af63ce8891b61a6b6f899bad78"></a><!-- doxytag: member="csl_usbAux.h::USB_isValidDataInFifoOut" ref="ga738d92af63ce8891b61a6b6f899bad78" args="(pUsbEpStatus peps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Bool USB_isValidDataInFifoOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpStatus.html">pUsbEpStatus</a>&#160;</td>
          <td class="paramname"><em>peps</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_isValidDataInFifoOut</b> </p>
<p><b>Description</b> <br/>
 This function checks validity of the data in the output FIFO</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        peps      -   End point status structure pointer
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>TRUE - FIFO out has valid data </li>
<li>FALSE - FIFO out no has valid data</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Checks the data in FIFO Out</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			Bool             fifoStatus;
			pUsbEpStatus     peps;
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			fifoStatus = USB_isValidDataInFifoOut(peps);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga29f63791a4ef0350bfe4993de81b1b35">CSL_USB_EP1</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga553fc33bd0be32e335c795e73bbf8305">CSL_USB_EP3</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga33ece104d6445d6638217841eee066e5">CSL_USB_EP4</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="structCSL__UsbEpStatus.html#af3b25534a800990fe26ad9ed400b3e6e">CSL_UsbEpStatus::dataReadFromFifo</a>, <a class="el" href="structCSL__UsbEpStatus.html#a0075dd5697663893796755a5bb1b4bf2">CSL_UsbEpStatus::dwEndpoint</a>, and <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c105f688a92a1205f4840a0ce768cdb"></a><!-- doxytag: member="csl_usb.h::USB_open" ref="ga8c105f688a92a1205f4840a0ce768cdb" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a> USB_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_open</b> </p>
<p><b>Description</b> <br/>
 This function returns handle to USB device</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number
     </pre></div><p><b> Return Value </b> CSL_UsbDevHandle </p>
<ul>
<li>Valid handle - Returned for success </li>
<li>NULL - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns handle to USB device which will be used by other functions</p>
<p><b>Modifies</b> <br/>
 USB context structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevNum    devNum;
			CSL_UsbDevHandle hUsbDev;

            devNum = CSL_USB0;
            .....
            .....
            USB_init();
			hUsbDev = USB_open(devNum);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga80f24ac9998b6b2b525ddc080993eee2"></a><!-- doxytag: member="csl_usb.h::USB_peekEvents" ref="ga80f24ac9998b6b2b525ddc080993eee2" args="(CSL_UsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__SYMBOL.html#ga87072d6bc79ccd6147812c988d653284">CSL_UsbEventMask</a> USB_peekEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_peekEvents</b> </p>
<p><b>Description</b> <br/>
 This function read all the pending USB_EVENTS associated with a particular USB endpoint</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbEventMask <br/>
 ORed combination of all the pending USB_EVENTS associated with a particular endpoint. <br/>
</p>
<p><b> Pre Condition </b> <br/>
 End point object should be initialized</p>
<p><b> Post Condition </b> <br/>
 1. Returns the end point events <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevHandle hUsbDev
			CSL_UsbEpHandle  hEp
			CSL_UsbEventMask usbEvents;
			CSL_Status       *status
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
            .....		
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            .....
            usbEvents = USB_peekEvents(hEp, &amp;status);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga0976835f84a5fedd800c643e6c86703e"></a><!-- doxytag: member="csl_usb.h::USB_postTransaction" ref="ga0976835f84a5fedd800c643e6c86703e" args="(CSL_UsbEpHandle hEp, Uint16 byteCnt, void *data, CSL_UsbIoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_postTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__SYMBOL.html#ga451c5b10120bc3d838c3768571f5255c">CSL_UsbIoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_postTransaction</b> </p>
<p><b>Description</b> <br/>
 This function transmits and receives USB data through an endpoint.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            byteCnt     Total number of bytes in the buffer pointed by *data
            Data        Pointer to a data buffer
            flags       ORed combination of USB Data Transfer Flags
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init end point should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Starts the data transfer</p>
<p><b>Modifies</b> <br/>
 USB FIFO registers/data buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            ....
			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga72b8feae60ffb2e627f5c63f289932fa">AC_reqGetConfiguration()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga28a08f70e283b7a37f8fc425ce7c7e65">AC_reqGetInterface()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga49de7509be688ccdb95c768112835b42">AC_reqGetMaxLUN()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga9a8bc1b593ae63a89fa2b788f35c11ca">AC_reqGetStatus()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gafbfba739fa8d53f66bfefbbac59f0087">CDC_reqGetConfiguration()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gaa18c7194cfd84eb6b8d958e744d44b6d">CDC_reqGetInterface()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga28f3d4fe60c6703b5630b04876ca4352">CDC_reqGetMaxLUN()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gabdd172dbd2208f7ac38e67678b545b68">CDC_reqGetStatus()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga2e84b637b78dd11a979c8a8425e6b2b6">HID_reqGetConfiguration()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga1183876eee179bef501be7c72e75047c">HID_reqGetDescriptor()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#gaa8cb0664ab75037722ee1208c2f39d13">HID_reqGetInterface()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#gae48e0da3633c84b34240373105d7ef7c">HID_reqGetMaxLUN()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga45d6740c6e6fe2028c9feb4a85fd5474">HID_reqGetStatus()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gade77de9d2839bc6ec5a7b354ac1276cf">MSC_HandleInquiry()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gab6f9256ab20a962631b58eb61cb0bcb7">MSC_HandleModeSense10()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga5bc3c80b4b8d4dc90dfaa9901d00ac80">MSC_HandleModeSense6()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga49469e6925eafc334bd55aa4bc5f3267">MSC_HandleRequestSense()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaacd692520e36b003e1c9112192c5c1ce">MSC_HandleStartStopUnit()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaf0cd33f55ed273163c24d04654c7903e">MSC_HandleStateReset()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gae0cf7468d0df0233275984398dd072f7">MSC_HandleStateSendCSW()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga365f33f75e7ded19a489336acf61bd1b">MSC_HandleStateSendData()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga7811b0cc7a5140164839fab44a3b932c">MSC_HandleStateSendingShortPkt()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gac6f1b38df1c546ae0f9bbb82e5029b81">MSC_HandleStateSendStall()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga4b07c75b1cd2664b4f3661ac4e363ef9">MSC_HandleVerify10()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga519d935865a17bd4dac66e03863b7cce">MSC_reqGetConfiguration()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gae342552f1b4fd3c27ead654215d7cad1">MSC_reqGetInterface()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gad3d5e95f491870fd5bebb7cd108db6a9">MSC_reqGetMaxLUN()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#gab25fc52b3701ce63235407366df10eed">MSC_reqGetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c40beb844907883d2bf1e00b59c8f38"></a><!-- doxytag: member="csl_usbAux.h::USB_processEP0In" ref="ga3c40beb844907883d2bf1e00b59c8f38" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_processEP0In </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_processEP0In</b> </p>
<p><b>Description</b> <br/>
 Writes data to End point 0</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev      -  USB device handle
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Writes data to end point0</p>
<p><b>Modifies</b> <br/>
 Ep0 FIFO registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			status = USB_processEP0In(hUsbDev);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="csl__error_8h.html#ac5a7875db1e0dec1a927698040b4b182">CSL_ESYS_INVPARAMS</a>, <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga3ea5752b72be519cccc704ed3369a31dafb54df283694dc092242c0093e4fbfda">CSL_USB_EP0_IDLE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga743aabc061187885dfb62cae6e3923fb">CSL_USB_MAX_EP0_FIFO_LEN</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae2f228461fa9c4e40849cc426a9eb3e8">CSL_USB_MIN</a>, <a class="el" href="structCSL__UsbEpStatus.html#a494f02bbd449b9d0160746e74d314d67">CSL_UsbEpStatus::dwPacketSizeAssigned</a>, <a class="el" href="structCSL__UsbContext.html#a5ddcf598a90a6f6249cf4c21c91933cb">CSL_UsbContext::ep0State</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#ac5163e07900bc1d7c152735b62ea8a57">CSL_UsbContext::fEP0BUFAvailable</a>, <a class="el" href="structCSL__UsbContext.html#a9f88cdd19250056ce3a5edfddb09d96d">CSL_UsbContext::fWaitingOnEP0BUFAvail</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbTransfer.html#ac4c77b234b43d2ed991f488ac9e932b3">CSL_UsbTransfer::prevTxferLen</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, and <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ga438a379bdbb16eda9c901bdce17d7d7c"></a><!-- doxytag: member="csl_usbAux.h::USB_processEP0Out" ref="ga438a379bdbb16eda9c901bdce17d7d7c" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_processEP0Out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_processEP0Out</b> </p>
<p><b>Description</b> <br/>
 Reads the data from End point 0</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev      -   USB device handle
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Reads data from end point0</p>
<p><b>Modifies</b> <br/>
 Ep0 data buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			status = USB_processEP0Out(hUsbDev);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbContext.html#a6065c6302f2f82fcb09d71b21a9ce9c8">CSL_UsbContext::cbOutEP0Buf</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="csl__error_8h.html#ac5a7875db1e0dec1a927698040b4b182">CSL_ESYS_INVPARAMS</a>, <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae2f228461fa9c4e40849cc426a9eb3e8">CSL_USB_MIN</a>, <a class="el" href="structCSL__UsbContext.html#a758c116a872fc4fb1dd36445a3c1de6d">CSL_UsbContext::dwOutEP0Buf</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#a093a424e0722cec32c39bda0904007d2">CSL_UsbContext::fOutPhaseCmd</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbTransfer.html#ac4c77b234b43d2ed991f488ac9e932b3">CSL_UsbTransfer::prevTxferLen</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, and <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="gafbb915c8c995a8b752653345fe32f2ef"></a><!-- doxytag: member="csl_usbAux.h::USB_readEP0Buf" ref="gafbb915c8c995a8b752653345fe32f2ef" args="(CSL_UsbDevHandle hUsbDev, DWORD *pBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_readEP0Buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_readEP0Buf</b> </p>
<p><b>Description</b> <br/>
 This function reads the End point0 buffer</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev       -   USB device handle
 	        pBusSpeed     -   USB Bus speed variable pointer
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_FAIL - Returned for failure</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Reads Ep0 data</p>
<p><b>Modifies</b> <br/>
 Ep0 Buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpConfig  epCfg
			CSL_UsbEpHandle  hEp
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_configEndpt(hEp, &amp;epCfg);
			....
			....
			status = USB_readEP0Buf(hUsbDev, hUsbDev-&gt;dwOutEP0Buf);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbContext.html#a940c8780aaa5476969c4fdd86a4a26f5">CSL_UsbContext::cbOutEP0DataReceived</a>, <a class="el" href="csl__error_8h.html#a68f8ee30ab7851128f90554d9139d486">CSL_ESYS_FAIL</a>, <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga743aabc061187885dfb62cae6e3923fb">CSL_USB_MAX_EP0_FIFO_LEN</a>, and <a class="el" href="structCSL__UsbContext.html#a758c116a872fc4fb1dd36445a3c1de6d">CSL_UsbContext::dwOutEP0Buf</a>.</p>

</div>
</div>
<a class="anchor" id="gaa6fdc35d5574b4f2b75c19bfdf54c809"></a><!-- doxytag: member="csl_usb.h::USB_releaseEndpt" ref="gaa6fdc35d5574b4f2b75c19bfdf54c809" args="(CSL_UsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_releaseEndpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_releaseEndpt</b> </p>
<p><b>Description</b> <br/>
 Function to release an endpoint</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp          Endpoint handle
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init, USB_open, USB_config and USB_requestEndpt functions should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Releases endpoint</p>
<p><b>Modifies</b> <br/>
 USB endpoint structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevNum    devNum;
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpHandle  hEp
			
            devNum = CSL_USB0;
            .....
            .....
            USB_init();
			hUsbDev = USB_open(devNum);
			status = USB_config(hUsbDev, &amp;usbCfg);			
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			status = USB_releaseEndpt(hEp);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga3ecd6973c919ea9f9315f953802dfc1b"></a><!-- doxytag: member="csl_usb.h::USB_requestEndpt" ref="ga3ecd6973c919ea9f9315f953802dfc1b" args="(CSL_UsbDevHandle hUsbDev, CSL_UsbEpNum epNum, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a> USB_requestEndpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gadd63cd53e03e1d7e632a8cbe348e3401">CSL_UsbEpNum</a>&#160;</td>
          <td class="paramname"><em>epNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_requestEndpt</b> </p>
<p><b>Description</b> <br/>
 Function to request the endpoint for data communication</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev          USB device handle
            epNum            End point number
			*status          Return status
     </pre></div><p><b> Return Value </b> CSL_UsbEpHandle </p>
<ul>
<li>Valid handle - Returned for success </li>
<li>NULL - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init, USB_open and USB_config functions should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns handle to endpoint</p>
<p><b>Modifies</b> <br/>
 USB endpoint structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevNum    devNum;
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
			CSL_UsbEpHandle  hEp
			
            devNum = CSL_USB0;
            .....
            .....
            USB_init();
			hUsbDev = USB_open(devNum);
			status = USB_config(hUsbDev, &amp;usbCfg);			
			hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga24d5e966fe13a5195d5f6c5d3348721d"></a><!-- doxytag: member="csl_usb.h::USB_resetDev" ref="ga24d5e966fe13a5195d5f6c5d3348721d" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_resetDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_resetDev</b> </p>
<p><b>Description</b> <br/>
 This function resets the USB device</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev        USB device handle
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init and USB_open should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Resets the USB device</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbDevHandle   hUsbDev;
            CSL_Status         status;

            usbConfig.maxCurrent = 50;
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
            ....
            ....
            status = USB_resetDev(hUsbDev);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga3d234787552dafd798c61094fd77f6d2"></a><!-- doxytag: member="csl_usb.h::USB_selfwakeup" ref="ga3d234787552dafd798c61094fd77f6d2" args="(CSL_UsbDevHandle hUsbDev, Uint32 wakeupDelay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_selfwakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>wakeupDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_selfwakeup</b> </p>
<p><b>Description</b> <br/>
 This function issues a self wakeup signal on the bus. This function can be mapped to an external event like pressing a button on the EVM. After responding to that event through a call back, USB device send a wakeup signal on the bus. NOTE: Application needs to send a delay as a parameter to this function. According to USB wakeup specification an approximate delay of 10mSecs(Min 2 to Max 15 mSecs) is required to send a wakeup signal on the bus. This delay is introduced between setting the resume bit to '1' and restting it to '0'. Application needs to decide a delay such that it is maximum enough to satisfy USB wakeup protocol and minimum to satisfy the USB driver performance.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev       USB device handle
            wakeupDelay   Delay between Resume bit set and reset
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init be called successfully and an external event should occur.</p>
<p><b> Post Condition </b> <br/>
 Send a wakeup signal on the bus.</p>
<p><b>Modifies</b> <br/>
 USB FADDR_POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            ....
            ....
            //This function call should be mapped to an external event
            wakeupDelay = 1000000;
            status = USB_selfwakeup(hUsbDev, wakeupDelay);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga2afe1be9825d404c775e8570b85338c2"></a><!-- doxytag: member="csl_usbAux.h::USB_setConfiguration" ref="ga2afe1be9825d404c775e8570b85338c2" args="(CSL_UsbDevHandle hUsbDev, Uint16 confVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_setConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>confVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setConfiguration</b> </p>
<p><b>Description</b> <br/>
 This function sets the end point configuration This is provided to use with MSC module This function is not required for standalone MUSB testing</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev       -   USB device handle
 	        confVal       -   configuration value
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Sets the end point configuration</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle hUsbDev;
			CSL_Status       status;
            CSL_UsbConfig    usbCfg
            .....
            .....
            USB_init();
			hUsbDev = USB_open(CSL_USB0);
			status = USB_config(hUsbDev, &amp;usbCfg);
			....
			....
			status = USB_setConfiguration(hUsbDev, 0x02);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga29f63791a4ef0350bfe4993de81b1b35">CSL_USB_EP1</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga553fc33bd0be32e335c795e73bbf8305">CSL_USB_EP3</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga33ece104d6445d6638217841eee066e5">CSL_USB_EP4</a>, and <a class="el" href="structCSL__UsbContext.html#aac3a9cdbbba2b9ade4bcfe3093233b0c">CSL_UsbContext::devNum</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga94ca6516fea56774c937e7719e72c827">AC_reqSetConfiguration()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga6ad1b66918beaf6e991cd6562da43617">CDC_reqSetConfiguration()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gac9c8a96a03792dbd71ddc6a1338cb43d">CDC_reqSetInterface()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#gac491f611e487b1ba946257d3c2a774fc">HID_reqSetConfiguration()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga3a4d663a672e9604cb98e5f69dd26e1b">MSC_reqSetConfiguration()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#gad4df068abe8eb407fa944791ab9120e0">MSC_reqSetInterface()</a>.</p>

</div>
</div>
<a class="anchor" id="ga25cb72d6bce692e49d554479df7c9173"></a><!-- doxytag: member="csl_usb.h::USB_setDevAddr" ref="ga25cb72d6bce692e49d554479df7c9173" args="(CSL_UsbDevHandle hUsbDev, Uint16 addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_setDevAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setDevAddr</b> </p>
<p><b>Description</b> <br/>
 This function sets the device Address to USB controller</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev       USB device handle
            addr          Address to set
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Configures device address registers</p>
<p><b>Modifies</b> <br/>
 Device address registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            ....
            status = USB_setDevAddr(hUsbDev, addr);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga704f5df35c5e743528bbbd0454b9ac21">AC_reqSetAddress()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga7fa53ff541381cd696c49069f8a098ba">CDC_reqSetAddress()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#gabae401b8e6af0ebea83448537fc008e7">HID_reqSetAddress()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#ga21286b327b55fe554b6c1651406be8bc">MSC_reqSetAddress()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6662427282d4c0a684887dfcd7112ec9"></a><!-- doxytag: member="csl_usb.h::USB_setFullSpeedMode" ref="ga6662427282d4c0a684887dfcd7112ec9" args="(CSL_UsbDevHandle hUsbDev, Uint16 ep0DataSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_setFullSpeedMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>ep0DataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setFullSpeedMode</b> </p>
<p><b>Description</b> <br/>
 This function is used to set the USB controller into full speed mode ep0DataSize is the size of the EP0 FIFO. This value should be within the range of values recommended by the USB specification.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hUsbDev       USB device handle
			ep0DataSize   Endpoint 0 data size
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB Init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 USB will be set for full speed mode</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            ....
            USB_setFullSpeedMode(hUsbDev, 0x20);

     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="gaafa1e6c7205ddf72f3fed97b0b2a3adb"></a><!-- doxytag: member="csl_usb.h::USB_setParams" ref="gaafa1e6c7205ddf72f3fed97b0b2a3adb" args="(CSL_UsbDevHandle hUsbDev, CSL_UsbEpHandle hEpObj[], Uint16 pSofTmrCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_setParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEpObj</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>pSofTmrCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setParams</b> </p>
<p><b>Description</b> <br/>
 This function initializes the global end point handle array</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev       USB device handle
            hEpObj        Pointer to a array of endpoint handle.
            pSofTmrCnt    8-bit counter value for the pre SOF timer.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Initializes global end point handle array</p>
<p><b>Modifies</b> <br/>
 Global end point handle array</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbEpObj    hEpHandleArray[CSL_USB_ENDPOINT_COUNT];
			CSL_Status      status;

			status = USB_setParams(hUsbDev, &amp;hEpHandleArray, 0);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga697ac4bdefb5d3c8cbd3bcead1e0b23b"></a><!-- doxytag: member="csl_usb.h::USB_setRemoteWakeup" ref="ga697ac4bdefb5d3c8cbd3bcead1e0b23b" args="(CSL_UsbDevHandle hUsbDev, CSL_UsbBoolean rmtWkpStat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_setRemoteWakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a>&#160;</td>
          <td class="paramname"><em>rmtWkpStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setRemoteWakeup</b> </p>
<p><b>Description</b> <br/>
 This function sets or clears Remote Wakeup Feature.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev       USB device handle
            rmtWkpStat    Remote wake up status flag
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init function should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Sets the remote wake up status</p>
<p><b>Modifies</b> <br/>
 Remote wakeup status variable in the USB global context structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            ....
            status = USB_setRemoteWakeup(hUsbDev, CSL_USB_TRUE);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gafd88f11be6f4a4df6adf684900374f21">AC_reqClearFeature()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga6f843961b00fa217e2d82ad5020d0364">AC_reqSetFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gab50d37c060294de0581f17672da8d7c6">CDC_reqClearFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gac5d1da006cea04d5f8785832dad2fbdb">CDC_reqSetFeature()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga3d5720b2087c7b397a172a04eb984ba0">HID_reqClearFeature()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga89fcc74dfd020591cbf2a66e5d896438">HID_reqSetFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gadda22cfca94fe72f4b0f72794512ec55">MSC_reqClearFeature()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#ga36d52d670751ab36289b5b9c5eda7578">MSC_reqSetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1befea5ae93ae7079e52df923a54c21"></a><!-- doxytag: member="csl_usb.h::USB_stallEndpt" ref="gaa1befea5ae93ae7079e52df923a54c21" args="(CSL_UsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_stallEndpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">CSL_UsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_stallEndpt</b> </p>
<p><b>Description</b> <br/>
 This function stalls an end point</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 End point init function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Stalls an end point associated with the passed handle</p>
<p><b>Modifies</b> <br/>
 USB control registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16             dataBuf[256];
			CSL_UsbDevHandle   hUsbDev
 			CSL_UsbEpHandle    hEp;
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
			...
			status = USB_stallEndpt(hEp);
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga6f843961b00fa217e2d82ad5020d0364">AC_reqSetFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gac5d1da006cea04d5f8785832dad2fbdb">CDC_reqSetFeature()</a>, <a class="el" href="group__CSL__HID__FUNCTION.html#ga89fcc74dfd020591cbf2a66e5d896438">HID_reqSetFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gab6f9256ab20a962631b58eb61cb0bcb7">MSC_HandleModeSense10()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga5bc3c80b4b8d4dc90dfaa9901d00ac80">MSC_HandleModeSense6()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaacd692520e36b003e1c9112192c5c1ce">MSC_HandleStartStopUnit()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga7811b0cc7a5140164839fab44a3b932c">MSC_HandleStateSendingShortPkt()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga4b07c75b1cd2664b4f3661ac4e363ef9">MSC_HandleVerify10()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#ga36d52d670751ab36289b5b9c5eda7578">MSC_reqSetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="ga41dec8edb199fdb574597228bf8b31fd"></a><!-- doxytag: member="csl_usb.h::USB_suspendDevice" ref="ga41dec8edb199fdb574597228bf8b31fd" args="(CSL_UsbDevHandle hUsbDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_suspendDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">CSL_UsbDevHandle</a>&#160;</td>
          <td class="paramname"><em>hUsbDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_suspendDevice</b> </p>
<p><b>Description</b> <br/>
 This function suspends the USB device. This function informs the application about the device suspend through a call back function.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUsbDev         USB device handle
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Puts the USB device into suspend mode.</p>
<p><b>Modifies</b> <br/>
 USB FADDR_POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbDevHandle   hUsbDev
            CSL_Status         status;

			USB_init();

			hUsbDev = USB_open(CSL_USB0);
            ....
            hEp = USB_requestEndpt(hUsbDev, CSL_USB_OUT_EP0, &amp;status);
            ....
            ....
            status = USB_suspendDevice(hUsbDev);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="gaf81115692729a4f51bdd61e391bde2f7"></a><!-- doxytag: member="csl_usbAux.h::USB_swapWords" ref="gaf81115692729a4f51bdd61e391bde2f7" args="(Uint16 *dataBuffer, Uint32 dataLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_swapWords </td>
          <td>(</td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>dataBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>dataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>USB_swapWords</b> </p>
<p><b>Description</b> <br/>
 This function swaps words in a given buffer</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            dataBuffer    Pointer to the buffer which words needs to be swapped
            dataLength    Length of data to be word swapped (In words)
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 Order of data in the given buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            #define USB_PACKET_SIZE (256)

            Uint16        usbBuf [USB_PACKET_SIZE];
            CSL_Status    status;

            status = USB_swapWords (usbBuf, USB_PACKET_SIZE);
     </pre></div><p> =========================================================================== </p>

<p>References <a class="el" href="csl__error_8h.html#ac5a7875db1e0dec1a927698040b4b182">CSL_ESYS_INVPARAMS</a>, and <a class="el" href="csl__error_8h.html#a8f03a584bbe51a4b3ea2fd16dda762f7">CSL_SOK</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__USB__FUNCTION.html#ga4e893d3e2d0c2beb2b646e4674544337">USB_confDmaTx()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga20e4e8227fc3b0678345d88b40ff4bf0">USB_dmaRxStop()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 27 2013 13:32:44 for C55XX CSL LP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
