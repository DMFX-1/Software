/* ============================================================================
 * Copyright (c) 2008-2012 Texas Instruments Incorporated.
 * Except for those rights granted to you in your license from TI, all rights
 * reserved.
 *
 * Software License Agreement
 * Texas Instruments (TI) is supplying this software for use solely and
 * exclusively on TI devices. The software is owned by TI and/or its suppliers,
 * and is protected under applicable patent and copyright laws.  You may not
 * combine this software with any open-source software if such combination would
 * cause this software to become subject to any of the license terms applicable
 * to such open source software.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
 * NO WARRANTIES APPLY TO THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY.
 * EXAMPLES OF EXCLUDED WARRANTIES ARE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE AND WARRANTIES OF NON-INFRINGEMENT,
 * BUT ALL OTHER WARRANTY EXCLUSIONS ALSO APPLY. FURTHERMORE, TI SHALL NOT,
 * UNDER ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, CONSEQUENTIAL
 * OR PUNITIVE DAMAGES, FOR ANY REASON WHATSOEVER.
 * ============================================================================
 */

/** @file csl_sar_IntcExample.c
 *
 *  @brief Test code to verify the SAR functionality in interrupt mode
 *
 *
 * \page    page16  CSL SAR EXAMPLE DOCUMENTATION
 *
 * \section SAR3   SAR EXAMPLE3 - INTERRUPT MODE TEST
 *
 * \subsection SAR3x    TEST DESCRIPTION:
 *		This test verifies the functionality of CSL SAR(Successive Approximation
 * Register) in interrupt mode. SAR module on C5515/C5517 DSP is used to convert the
 * voltage generated by the key pad available on the C5515/C5517 EVM to digital
 * values. This key pad is having 10 button with each button having a different
 * digital value corresponding to the voltage generated when it is pressed.
 *
 * During the test C5515/C5517 key pad button voltage is read and the converted
 * digital value is displayed in the CCS "stdout" window. This digital value
 * corresponds to the voltage of the button pressed while running the test.
 * SAR module is having six channels to read the data. This test configures
 * channel four for reading the button voltage in interrupt mode. CSL INTC
 * module should be configured and SAR ISR should registered before starting
 * the SAR data conversion. After successful configuration of the SAR, voltage
 * conversion is started using the CSL API SAR_startConversion(). Digital value
 * of the button voltage is read in the ISR for 40 times and is displayed in
 * the CCS "stdout" window. After reading 40 digital values SAR data conversion
 * is stopped and CSL SAR module will be closed.
 *
 * @verbatim
   Digital values corresponding to the button voltage will vary slightly
   depending on the system clock value. Below are the range of values for
   each button available on the C5515/C5517 EVM key pad.

    No button pushed: 0x3fb - 0x3ff
    SHIFT:    0x230 - 0x238
    STOP:     0x0
    RWD:      0x20f - 0x216
    MENU:     0x367 - 0x374
    DN:       0x2bc - 0x2c6
    SEL/PLAY: 0x1d3 - 0x1d8
    UP:       0x24f - 0x258
    REC:      0xd5  - 0xd8
    FWD:      0x163 - 0x167
    MODE:     0x30b - 0x316

   @endverbatim
 *
 * NOTE: TEST SHOULD NOT BE RUN BY SINGLE STEPPING AFTER ENABLING THE SAR
 * INTERRUPTS. DOING SO WILL LEAD TO IMPROPER HANDLING OF THE INTERRUPTS
 * AND TEST FAILURE.
 *
 * NOTE: THIS TEST HAS BEEN DEVELOPED TO WORK WITH CHIP VERSIONS C5515 AND
 * C5517. MAKE SURE THAT PROPER CHIP VERSION MACRO IS DEFINED IN THE FILE
 * c55xx_csl\inc\csl_general.h.
 *
 * \subsection SAR3y    TEST PROCEDURE:
 *  @li Open the CCS and connect the target (C5515/C5517 EVM)
 *  @li Open the project "CSL_SAR_IntcExample.pjt" and build it
 *  @li Load the program on to the target
 *  @li Set the PLL frequency to 12.288MHz
 *  @li Press any one of the buttons present on C5515/C5517 EVM key pad.
 *  @li Run the program and observe the test result
 *  @li Repeat the test at the following PLL frequencies
 *      C5515: 60MHz and 100MHz
 *      C5517: 60MHz, 100MHz, 150MHz and 200MHz
 *  @li Repeat the test in Release mode
 *
 * \subsection SAR3z    TEST RESULT:
 *  @li All the CSL APIs should return success
 *  @li Digital value corresponding to a button voltage should be within the
 *     range specified in the test procedure.
 *
 */

/* ============================================================================
 * Revision History
 * ================
 * 20-Sep-2008 Created
 * 20-Jul-2012 Added C5517 compatibility
 * ============================================================================
 */

/* Inclusion of header files */
#include <csl_sar.h>
#include <csl_intc.h>
#include <csl_general.h>
#include <pal_osWait.h>
#include <csl_sar_intc.h>
#include "DMFX1_CSL_BIOS_cfg.h"

/* Global Structure Declaration*/
CSL_SarHandleObj SarObj;            /* SAR object structure */
CSL_SarHandleObj *SarHandle;        /* SAR handle           */
Uint16           SarData[POTENTIOMETER] = {0};        /* SAR Read Buffer      */
Uint16 			 chanNo = 0;						// SAR Channel number 0-3 or 2-3

int	sar_pot_init(void)
{
    Bool flag = 1;
    int result;
    /* Testing of SAR A/D Keypad Voltage Measurement */
    CSL_Status    status;
    CSL_SarChSetup param;
    result = -1;

    /* Initialize the SAR module */
    status = SAR_init();
    if(status != CSL_SOK)
    {
        LOG_printf(&trace, "SAR Init Failed!!");
        return (result) ;
    }

    /* Open SAR channel */
	status = SAR_chanOpen(&SarObj,CSL_SAR_CHAN_2);
	SarHandle = &SarObj;
	if(status != CSL_SOK)
	{
		LOG_printf(&trace, "SAR_chanOpen Failed!!");
		return result;
	}

	/* Initialize channel */
	status = SAR_chanInit(SarHandle);
	if(status != CSL_SOK)
	{
		LOG_printf(&trace, "SAR_chanInit %d Failed!!");
		return(result);
	}

    /* Clear any pending Interrupt */
    IRQ_clear(SAR_EVENT);
    IRQ_test(SAR_EVENT,&flag);
    /* Register the ISR */
    //IRQ_plug(SAR_EVENT,&sarISR);  // ISR registered on DSP/BIO config and controlled by HWI dispatcher

	param.OpMode =  CSL_SAR_POLLING;		// CSL_SAR_POLLING clears STATUSMASK
	param.MultiCh = CSL_SAR_NO_DISCHARGE;
	param.RefVoltage = CSL_SAR_REF_VIN;
	param.SysClkDiv = 18749; // 12MHz / 18750 = 640Hz / 10-bit/sample => fs = 64Hz
	/* Configuration for SAR module */
	status = SAR_chanSetup(SarHandle,&param);
	if(status != CSL_SOK)
	{
		LOG_printf(&trace, "SAR_chanConfig Failed!!");
		return(result);
	}

	/* Set channel cycle set */
	status = SAR_chanCycSet(SarHandle,CSL_SAR_SINGLE_CONVERSION);
	if(status != CSL_SOK)
	{
		LOG_printf(&trace, "SAR_chanCycSet Failed!!");
		return(result);
	}
	/* set ADC Measurement parameters */
	status = SAR_A2DSetParam(SarHandle);
	if(status != CSL_SOK)
	{
		LOG_printf(&trace, "SAR_A2DMeasParamSet Failed!!");
		return(result);
	}

    /* Enabling Interrupt */
    IRQ_enable(SAR_EVENT);
    IRQ_globalEnable();

    /* Set channel and start the conversion */
    status = SAR_SetCh_StrtCnv(SarHandle, 0);
    if(status != CSL_SOK)
    {
        LOG_printf(&trace, "SAR_startConversion Failed!!");
        return(result);
    }
	// SAR Initialization ends here
    return(result);
}

void sar_test_pot_voltage ()
{
    int i = 0, j = 0;

	/* ISR runs for 64 times */
    for(i = 0; i < 64; i++)
    {
        IRQ_globalDisable();

    	for(j = 0; j < POTENTIOMETER; j++)
    		LOG_printf(&trace, "SAR channel = %d, data = %d", j, SarData[j]);
		SarData[chanNo] = 0xFFF;
	    IRQ_globalEnable();
  	    PAL_osWaitMsecs(100);
    }
}

int sar_pot_deinit()
{
    CSL_Status    status;
    int result = -1;

    // SAR disabling starts here
    IRQ_disable(SAR_EVENT);

    /* Stop the conversion */
    status = SAR_stopConversion(SarHandle);
    if(status != CSL_SOK)
    {
        LOG_printf(&trace, "SAR_stopConversion Failed!!");
    }
	/* Clear any pending interrupts */
	IRQ_clearAll();

	/* Disable all the interrupts */
	IRQ_disableAll();

    //Disable interrupt
    IRQ_globalDisable();

    /* Close the channel */
    status = SAR_chanClose(SarHandle);
    if(status != CSL_SOK)
    {
        LOG_printf(&trace, "SAR_chanClose Failed!!");
        return(result);
    }

    /* Deinit */
    status = SAR_deInit();
    if(status != CSL_SOK)
    {
        LOG_printf(&trace, "SAR_deInit Failed!!");
        return(result);
    }
    result = 0;
    return(result);
}


// ISR to read ADC data
void sarISR(void)
{
#ifdef DEBUG
	Uint16 ReadChannel;
#endif
	SarData[chanNo] = SarHandle->baseAddr->SARDATA;
#ifdef DEBUG
	ReadChannel = ((SarData[chanNo] & 0x7000)>>12)-2;
#endif
	SarData[chanNo] &= 0x0FFF;
#if SAR_BUG
#if (POTENTIOMETER==4)
	if (chanNo == 0)
		SarData[0] = 1010 - ((SarData[0]*89)>>6);  // scale channel 0 from 725 to 1004 (10-bits)
	else
		SarData[chanNo] = 1010 - SarData[chanNo];
#else
	SarData[chanNo] = 1010 - SarData[chanNo];
#endif
#else
	if (chanNo == 0)
		SarData[0] = (SarData[0]*89)>>6;  // scale channel 0 from 725 to 1004 (10-bits)
#endif
#ifdef DEBUG
	if(chanNo != ReadChannel) {
		LOG_printf(&trace, "ISR: SAR data channel %d != %d", ReadChannel, chanNo);
	}
	LOG_printf(&trace, "ISR: SAR channel = %d, data = %d", chanNo, SarData[chanNo]);
#endif
	IRQ_clear(SAR_EVENT);
	(chanNo == (POTENTIOMETER-1)) ? chanNo = 0 : chanNo++;	// Increases circularly channel number 0-3
#if (POTENTIOMETER==2)
    SAR_SetCh_StrtCnv(SarHandle, chanNo+2);	// Starts next SAR single conversion and sets new channel
#else
    SAR_SetCh_StrtCnv(SarHandle, chanNo);	// Starts next SAR single conversion and sets new channel
#endif
}

// SAR ADC set parameters AVDD measure disable, GNDON disable, NoHV enable, Half bit disable
CSL_Status SAR_A2DSetParam (
SAR_Handle                   hSar
)
{
    CSL_Status status;
    if(NULL == hSar)
    {
        return CSL_ESYS_BADHANDLE;
    }
	/* Enabling SAR A/D AVddMeas bit */
	CSL_FINST (hSar->baseAddr->SARPINCTRL ,ANACTRL_SARPINCTRL_AVDDMEAS,
		CLEAR);
	/* Disabling SAR A/D GndSwOn bit */
	CSL_FINST (hSar->baseAddr->SARPINCTRL ,ANACTRL_SARPINCTRL_GNDON,
		CLEAR);
	// Sets NoHV bit
    hSar->baseAddr->SARPINCTRL = ((hSar->baseAddr->SARPINCTRL) & ~0x4) | 0x0004;
	/* Disabling SAR A/D Half bit */
	CSL_FINST (hSar->baseAddr->SARPINCTRL, ANACTRL_SARPINCTRL_HALF,
		CLEAR);

	status = CSL_SOK;
    return status;
}

// Set SAR ADC channel and starts single conversion
CSL_Status SAR_SetCh_StrtCnv (
SAR_Handle                   hSar,
Uint16		                 channel
)
{

    if(NULL == hSar)
    {
        return CSL_ESYS_BADHANDLE;
    }
	CSL_FINS (CSL_SAR_REGS->SARCTRL, ANACTRL_SARCTRL_CHSEL, channel+2);  // converts channels 0-3 to 2-5
    /* Start SAR A/D conversion */
    CSL_FINST (hSar->baseAddr->SARCTRL, ANACTRL_SARCTRL_ADCSTRT, SET);

    return CSL_SOK;
}
